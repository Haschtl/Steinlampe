<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#0b0f1a" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/svg+xml" href="icon-lamp.svg" />
  <title>Quarzlampe Web BLE</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: #11182a;
      --border: #1f2b44;
      --accent: #5be6ff;
      --accent2: #8cf59b;
      --text: #eef2ff;
      --muted: #9fb2cc;
    }
    * { box-sizing: border-box; }
    body { font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif; margin: 0; background: radial-gradient(circle at 20% 20%, #111a2d, #0b0f1a 50%), #0b0f1a; color: var(--text); padding: 1.2rem; }
    h1 { margin: 0 0 0.6rem; letter-spacing: 0.02em; }
    h3 { margin-top: 0; color: var(--accent); }
    button, input, textarea { margin: 0.15rem; padding: 0.45rem 0.65rem; border-radius: 6px; border: 1px solid var(--border); background: #0f1525; color: var(--text); }
    button { cursor: pointer; transition: all 0.15s ease; }
    button:hover { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 0 1px #1a2438; }
    input, textarea { background: #0d1322; }
    select { background:#0f1525; color:var(--text); border:1px solid var(--border); border-radius:8px; padding:0.5rem 0.75rem; min-width:170px; appearance:none; -moz-appearance:none; -webkit-appearance:none; background-image: linear-gradient(45deg, transparent 50%, var(--accent) 50%), linear-gradient(135deg, var(--accent) 50%, transparent 50%); background-position: right 12px top 55%, right 6px top 55%; background-size: 10px 10px, 10px 10px; background-repeat: no-repeat; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1rem; }
    .card { border: 1px solid var(--border); padding: 0.85rem; border-radius: 10px; background: linear-gradient(145deg, rgba(255,255,255,0.02), rgba(0,0,0,0.2)); box-shadow: 0 5px 25px rgba(0,0,0,0.35); }
    #log { width: 100%; height: 220px; background:#0b0f1a; color: #8ce5ff; padding: 0.6rem; overflow-y: auto; font-family: 'SFMono-Regular', Menlo, monospace; border:1px solid var(--border); border-radius:8px; }
    .log-block { border:1px solid var(--border); border-radius:10px; overflow:hidden; background:#0b0f1a; box-shadow: 0 4px 20px rgba(0,0,0,0.25); }
    .log-block #log { border:none; border-bottom:1px solid var(--border); border-radius:0; margin:0; }
    .log-row { background:#0d1322; padding:0.5rem; }
    label { display:block; margin-top:0.35rem; font-size: 0.9rem; color: var(--muted); }
    .row { display:flex; flex-wrap:wrap; gap:0.4rem; align-items:center; }
    .pill { padding: 0.35rem 0.6rem; border-radius: 999px; background: #10172a; border:1px solid var(--border); color: var(--muted); font-size: 0.9rem; }
    .header { display:flex; gap:0.75rem; align-items:center; margin-bottom: 0.75rem; flex-wrap: wrap; }
    .header .pill, .header button { flex-shrink: 0; }
    #status { color: var(--accent2); }
    textarea { resize: vertical; }
    #quickList { display:grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap:0.45rem; align-items:start; width:100%; }
    .quick-label { display:flex; align-items:center; gap:0.35rem; padding:0.38rem 0.55rem; border:1px solid var(--border); border-radius:8px; background:#0d1322; color:var(--text); width:100%; }
    .quick-label input { accent-color: var(--accent); }
    table.info-table { width:100%; border-collapse: collapse; margin-top:0.5rem; }
    table.info-table th, table.info-table td { border:1px solid var(--border); padding:0.45rem 0.55rem; text-align:left; }
    table.info-table th { background:#10172a; color:var(--accent); }
    table.info-table tbody tr:nth-child(even) { background:#0d1322; }
    .copy-btn { padding:0.3rem 0.5rem; border-radius:6px; border:1px solid var(--border); background:#0f1525; color:var(--text); cursor:pointer; }
    .input-group { display:flex; align-items:stretch; gap:0; width:100%; }
    .input-group input,
    .input-group textarea { border-top-right-radius:0; border-bottom-right-radius:0; margin-right:0; flex:1; min-width:0; }
    .input-group button { border-top-left-radius:0; border-bottom-left-radius:0; margin-left:0; margin-right:0; }
    .slider-group { margin:0.35rem 0; }
    .slider-top { display:flex; justify-content:space-between; align-items:center; gap:0.6rem; color:var(--muted); }
    .slider-number { width:90px; text-align:right; }
    .slider-row { display:flex; gap:0.6rem; align-items:center; }
    .slider-row input[type=range] { flex:1; accent-color: var(--accent); height: 14px; border-radius: 999px; background: linear-gradient(90deg, rgba(91,230,255,0.4) 0%, rgba(88,129,255,0.2) 100%); }
    .slider-row input[type=range]::-webkit-slider-thumb { width:22px; height:22px; border-radius:50%; background: #0b0f1a; border:2px solid var(--accent); box-shadow: 0 6px 14px rgba(0,0,0,0.4); }
    .slider-row input[type=range]::-moz-range-thumb { width:22px; height:22px; border-radius:50%; background: #0b0f1a; border:2px solid var(--accent); box-shadow: 0 6px 14px rgba(0,0,0,0.4); }
    .bar-row { display:flex; align-items:center; gap:0.6rem; margin:0.25rem 0; }
    .bar-row input[type=range] { flex:1; accent-color: var(--accent2); }
    .bar-row input[type=number] { width:80px; text-align:right; }
    .bar-row button { padding:0.3rem 0.6rem; }
  </style>
</head>
<body>
  <div class="header">
    <img src="icon-lamp.svg" alt="Lamp Icon" style="width:40px; height:40px; border-radius:8px; border:1px solid var(--border); background:#0b0f1a; padding:4px;" />
    <h1>Quarzlampe Web BLE</h1>
    <button id="btnConnect">Connect</button>
    <button id="btnSerial">Connect Serial</button>
    <label class="pill" style="cursor:pointer;">
      <input type="checkbox" id="autoReconnect" style="margin-right:0.35rem;" checked />Auto-reconnect
    </label>
    <span class="pill" id="status">Not connected</span>
  </div>

  <div class="grid">
    <div class="card">
      <h3 style="display:flex; align-items:center; gap:0.6rem; justify-content:space-between;">
        <span>Lamp</span>
        <div class="row" style="gap:0.3rem; align-items:center; margin:0;">
          <label class="pill" style="cursor:pointer; margin:0;">
            <input type="checkbox" id="lampToggle" style="margin-right:0.35rem;" />On
          </label>
        </div>
      </h3>
      <div class="input-group" style="max-width: 100%;">
        <button data-cmd="prev" style="border-radius:6px 0 0 6px;">Prev</button>
        <select id="modeSelect" style="min-width:170px; border-radius:0; margin:0; height:100%; margin-top: 0.125rem; padding-top:0.5rem; padding-bottom:0.35rem;"></select>
        <button data-cmd="next" style="border-radius:0 6px 6px 0;">Next</button>
      </div>
      <div class="row">
        <label class="pill" style="cursor:pointer;">
          <input type="checkbox" id="autoToggle" style="margin-right:0.35rem;" />AutoCycle
        </label>

        <label class="pill" style="cursor:pointer;">
          <input type="checkbox" id="patFadeToggle" style="margin-right:0.35rem;" />Pattern Fade
        </label>
        <button data-cmd="sync" title="Align lamp state to physical switch">Sync</button>
      </div>
      <div class="slider-group">
        <div class="slider-top">
          <span>Speed</span>
          <input id="patSpeedNum" class="slider-number" type="number" min="0.1" max="5" step="0.1" value="1.0" />
        </div>
        <div class="slider-row">
          <input id="patSpeed" type="range" min="0.1" max="5" step="0.1" value="1.0" />
        </div>
      </div>
      <div class="slider-group">
        <div class="slider-top">
          <span>Brightness</span>
          <div style="display:flex; gap:0.35rem; align-items:center;">
            <input id="briNum" class="slider-number" type="number" min="1" max="100" step="1" value="70" />
            <span id="briVal" style="display:none;">70</span>
          </div>
        </div>
        <div class="slider-row">
          <input id="bri" type="range" min="1" max="100" value="70" />
        </div>
      </div>

      <div class="slider-group">
        <div class="slider-top">
          <span>Fade</span>
          <input id="patFadeNum" class="slider-number" type="number" min="0.01" max="5" step="0.01" value="1.00" />
        </div>
        <div class="slider-row">
          <input id="patFadeAmt" type="range" min="0.01" max="5" step="0.01" value="1.00" />
        </div>
      </div>

      <div class="row">
        <label>Ramp (ms)</label>
        <div class="input-group">
          <input id="rampMs" type="number" min="50" max="5000" step="50" value="400" />
          <button id="btnRamp">Set</button>
        </div>
      </div>
      <div class="row" style="flex-wrap:wrap; gap:0.6rem;">
        <div>
          <label>Ramp On</label>
          <div class="row" style="gap:0.4rem; align-items:center;">
            <select id="rampEaseOn">
              <option value="linear">linear</option>
              <option value="ease">ease</option>
              <option value="ease-in">ease-in</option>
              <option value="ease-out">ease-out</option>
              <option value="ease-in-out">ease-in-out</option>
            </select>
            <input id="rampPowOn" type="number" min="0.01" max="10" step="0.01" value="2.0" style="width:90px;" />
          </div>
        </div>
        <div>
          <label>Ramp Off</label>
          <div class="row" style="gap:0.4rem; align-items:center;">
            <select id="rampEaseOff">
              <option value="linear">linear</option>
              <option value="ease">ease</option>
              <option value="ease-in">ease-in</option>
              <option value="ease-out">ease-out</option>
              <option value="ease-in-out">ease-in-out</option>
            </select>
            <input id="rampPowOff" type="number" min="0.01" max="10" step="0.01" value="2.0" style="width:90px;" />
          </div>
        </div>
      </div>
    </div>

    <div class="card">
      <h3 style="display:flex; align-items:center; gap:0.6rem; justify-content:space-between;">
        <span>Presence</span>
        <label class="pill" style="cursor:pointer; margin:0;">
          <input type="checkbox" id="presenceToggle" style="margin-right:0.35rem;" />Presence
        </label>
      </h3>
      <div class="row">
        <div class="input-group">
          <input id="presenceMac" type="text" placeholder="AA:BB:CC:DD:EE:FF" size="20" />
          <button id="btnPresenceSet">Set</button>
          <button id="btnPresenceClear" data-cmd="presence clear" style="border-radius:0 6px 6px 0;">Clear</button>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Settings</h3>
      <div class="row" style="align-items:flex-start; flex-direction: column;">
        <label style="min-width:120px;">Quick tap modes:</label>
        <div id="quickList" class="row" style="flex:1; gap:0.05rem;"></div>
        <button id="btnQuickApply" title="Applies selection for fast switch tap cycling">Apply</button>
      </div>
      <div class="row">
        <label>IdleOff (min, 0=off)</label>
        <div class="input-group">
          <input id="idleMin" type="number" min="0" max="180" step="1" value="0" />
          <button id="btnIdle">Set</button>
        </div>
      </div>
      <div class="row" style="align-items:flex-start;">
        <div class="input-group" style="flex:1;">
          <textarea id="importArea" rows="2" style="flex:1; min-width:180px;" placeholder="paste cfg export here"></textarea>
          <button id="btnImport">Import cfg</button>
        </div>
      </div>
    </div>

    <div class="card">
      <h3 style="display:flex; align-items:center; gap:0.6rem; justify-content:space-between;">
        <span>Touch</span>
        <label class="pill" style="cursor:pointer; margin:0;">
          <input type="checkbox" id="touchDimToggle" style="margin-right:0.35rem;" />TouchDim
        </label>
      </h3>
      <div class="row">
        <label>Touch hold (ms)</label>
        <div class="input-group">
          <input id="touchHold" type="number" min="500" max="5000" step="100" value="1000" />
          <button id="btnTouchHold">Set</button>
        </div>
      </div>
      <div class="row">
        <label>Touch On</label>
        <div class="input-group" style="max-width:170px;">
          <input id="touchOn" type="number" min="1" max="200" step="1" value="10" />
          <button id="btnTouchTune">Set</button>
        </div>
        <label>Touch Off</label>
        <div class="input-group" style="max-width:170px;">
          <input id="touchOff" type="number" min="1" max="200" step="1" value="6" />
          <button id="btnTouchTuneOff">Set</button>
        </div>
      </div>
      <div class="row">
        <button id="btnCalibTouch">calibrate touch</button>
        <button id="btnCalib">calibrate baseline</button>
      </div>
    </div>

    <div class="card">
      <h3>Custom</h3>
      <div class="row">
        <div class="input-group">
          <input id="customStep" type="number" min="100" max="5000" step="50" value="800" />
          <button id="btnCustomStep">Set Step</button>
        </div>
      </div>
      <h4 style="margin-bottom:0.3rem;">Pattern Editor</h4>
      <div id="customEditor"></div>
      <div class="row" style="gap:0.5rem;">
        <button id="btnCustomAdd">Add Point</button>
        <button id="btnCustomClear">Clear</button>
        <button id="btnCustomSend">Send Custom</button>
      </div>
      <label>CSV values (0..1)</label>
      <textarea id="customCsv" rows="4" style="width:100%;"></textarea>
    </div>

  </div>

  <div class="row" style="align-items:center; justify-content:space-between;">
    <h3 style="margin:0;">Log</h3>
    <div class="row" style="gap:0.4rem;">
      <button id="btnStatus">Status</button>
      <button id="btnCfgExport">cfg export</button>
    </div>
  </div>
  <div class="log-block">
    <pre id="log"></pre>
    <div class="row log-row" style="margin:0;">
      <input id="cmdInput" type="text" placeholder="type command" style="flex:1; min-width:200px;" />
      <button id="btnSend">Send</button>
    </div>
  </div>

  <div class="grid" style="margin-top:1rem;">
    <div class="card">
      <h3>BLE GUIDs</h3>
      <table class="info-table">
        <thead><tr><th>Label</th><th>Value</th><th>Copy</th></tr></thead>
        <tbody id="guidTable"></tbody>
      </table>
    </div>
    <div class="card">
      <h3>Command Reference & Links</h3>
      <table class="info-table">
        <thead><tr><th>Command</th><th>Description</th></tr></thead>
        <tbody>
          <tr><td>on / off / toggle</td><td>Switch lamp power</td></tr>
          <tr><td>mode N / next / prev</td><td>Select pattern</td></tr>
          <tr><td>auto on|off</td><td>Auto-cycle patterns</td></tr>
          <tr><td>bri X</td><td>Brightness 0..100%</td></tr>
          <tr><td>quick 1,2,...</td><td>Set fast-switch cycle list</td></tr>
          <tr><td>pat scale 0.1-5</td><td>Pattern speed factor</td></tr>
          <tr><td>touchdim on|off</td><td>Enable touch dimming</td></tr>
          <tr><td>touch tune on off</td><td>Set touch thresholds</td></tr>
          <tr><td>ramp MS / idle MIN</td><td>Ramp and auto-off</td></tr>
          <tr><td>presence on|off|set|clear</td><td>Presence control</td></tr>
          <tr><td>wake [s] / sleep [m]</td><td>Start fades</td></tr>
          <tr><td>custom ...</td><td>Custom pattern CSV</td></tr>
          <tr><td>cfg export / import</td><td>Backup/restore settings</td></tr>
          <tr><td>status / help</td><td>Show status or commands</td></tr>
        </tbody>
      </table>
      <div class="row" style="margin-top:0.6rem;">
        <a class="pill" href="https://play.google.com/store/apps/details?id=net.dinglisch.android.taskerm" target="_blank" rel="noopener">Tasker (Play Store)</a>
        <a class="pill" href="https://github.com/Haschtl/Tasker-Ble-Writer/actions" target="_blank" rel="noopener">Tasker-BLE-Writer Actions</a>
    <a class="pill" href="https://github.com/Haschtl/Steinlampe/actions/workflows/ci.yml" target="_blank" rel="noopener">Firmware Build (Actions)</a>
      </div>
    </div>
  </div>

  <script>
    const SERVICE = 'd94d86d7-1eaf-47a4-9d1e-7a90bf34e66b';
    const CMD_CHAR = '4bb5047d-0d8b-4c5e-81cd-6fb5c0d1d1f7';
    const STATUS_CHAR = 'c5ad78b6-9b77-4a96-9a42-8e6e9a40c123';
    const MODE_NAMES = [
      'Konstant', 'Atmung', 'Pulsierend', 'Funkeln', 'Kerze Soft',
      'Kerze', 'Lagerfeuer', 'Stufen', 'Zwinkern', 'Custom', 'Musik'
    ];

    let cmdChar = null;
    let statusChar = null;
    let device = null;
    let reconnecting = false;
    let serialPort = null;
    let serialWriter = null;
    let serialReader = null;
    let lastCmdText = '';
    let lastCmdTime = 0;

    const logEl = document.getElementById('log');
    let lastLogLine = '';
    let lastLogMs = 0;
    function log(msg) {
      const now = Date.now();
      if (msg === lastLogLine && (now - lastLogMs) < 400) {
        return; // dedupe bursts
      }
      lastLogLine = msg;
      lastLogMs = now;
      const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      logEl.textContent += line;
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function connect() {
      if (!navigator.bluetooth) {
        log('Web Bluetooth not supported or not available (needs Chrome/Edge over HTTPS/localhost; enable chrome://flags/#enable-experimental-web-platform-features on some platforms).');
        return;
      }
      try {
        let reqOpts = { filters: [{ services: [SERVICE] }], optionalServices: [SERVICE] };
        try {
          device = await navigator.bluetooth.requestDevice(reqOpts);
        } catch (e1) {
          log('Filter request failed, trying acceptAllDevices...');
          device = await navigator.bluetooth.requestDevice({ acceptAllDevices: true, optionalServices: [SERVICE] });
        }

        log('Connecting...');
        const server = await device.gatt.connect();
        device.addEventListener('gattserverdisconnected', async () => {
          log('Disconnected');
          document.getElementById('status').textContent = 'Disconnected';
          if (document.getElementById('autoReconnect').checked && device) {
            reconnecting = true;
            try {
              log('Reconnecting...');
              await device.gatt.connect();
              log('Reconnected');
              document.getElementById('status').textContent = 'Connected to ' + device.name;
            } catch (e) {
              log('Reconnect failed: ' + e);
            } finally {
              reconnecting = false;
            }
          }
        });
        log('Discover service');
        const service = await server.getPrimaryService(SERVICE);

        // List available characteristics for debugging
        try {
          const chars = await service.getCharacteristics();
          log('Found chars: ' + chars.map(c => c.uuid).join(', '));
        } catch (e) {
          log('Could not list characteristics: ' + e);
        }

        log('Discover cmd/status chars');
        try {
          cmdChar = await service.getCharacteristic(CMD_CHAR);
        } catch (e) {
          log('Cmd char not found: ' + e);
          throw e;
        }
        try {
          statusChar = await service.getCharacteristic(STATUS_CHAR);
        } catch (e) {
          log('Status char not found: ' + e);
          throw e;
        }

        let notified = false;
        // Attach notifications on cmdChar (firmware sends feedback here)
        if (cmdChar && cmdChar.properties && cmdChar.properties.notify) {
          try {
            await cmdChar.startNotifications();
            cmdChar.addEventListener('characteristicvaluechanged', onNotify);
            log('Cmd notify enabled');
          } catch (e) {
            log('Cmd notify not available: ' + e);
          }
        }

        // Attach notifications on statusChar (UI updates only, no log to avoid duplicates)
        if (statusChar && statusChar.properties && statusChar.properties.notify) {
          try {
            await statusChar.startNotifications();
            statusChar.addEventListener('characteristicvaluechanged', (ev) => {
              const txt = new TextDecoder().decode(ev.target.value || new DataView());
              txt.split(/\r?\n/).forEach(line => updateUIFromStatus(line.trim()));
            });
            log('Status notify enabled');
            notified = true;
          } catch (e) {
            log('Status notify not available; using read fallback');
          }
        } else {
          log('Status notify not supported by firmware');
        }

        if (statusChar && !notified) {
          try {
            const val = await statusChar.readValue();
            const txt = new TextDecoder().decode(val || new DataView());
            txt.split(/\r?\n/).forEach(line => updateUIFromStatus(line.trim()));
          } catch (e2) {
            log('Status read failed: ' + e2);
          }
        }
        document.getElementById('status').textContent = 'Connected to ' + device.name;
        log('Connected to ' + device.name);
      } catch (e) {
        log('Connect error: ' + e);
      }
    }

    async function connectSerial() {
      if (!('serial' in navigator)) {
        log('Web Serial not supported (needs Chrome/Edge over HTTPS/localhost)');
        return;
      }
      try {
        serialPort = await navigator.serial.requestPort();
        await serialPort.open({ baudRate: 115200 });
        const encoder = new TextEncoderStream();
        serialWriter = encoder.writable.getWriter();
        encoder.readable.pipeTo(serialPort.writable);

        const reader = serialPort.readable.getReader();
        const decoder = new TextDecoder();
        serialReader = reader;
        let buffer = '';
        log('Serial connected');
        document.getElementById('status').textContent = 'Serial connected';
        (async () => {
          try {
            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              buffer += decoder.decode(value, { stream: true });
              let idx;
              while ((idx = buffer.indexOf('\n')) >= 0) {
                const line = buffer.slice(0, idx).trim();
                buffer = buffer.slice(idx + 1);
                if (line) {
                  log(line);
                  onNotify({ target: { value: new TextEncoder().encode(line) } });
                }
              }
            }
          } catch (e) {
            log('Serial read error: ' + e);
          } finally {
            reader.releaseLock();
            serialReader = null;
            serialWriter = null;
            if (serialPort) await serialPort.close();
            serialPort = null;
            document.getElementById('status').textContent = 'Disconnected';
          }
        })();
      } catch (e) {
        log('Serial connect error: ' + e);
      }
    }

    function onNotify(e) {
      const txt = new TextDecoder().decode(e.target.value || new DataView());
      txt.split(/\r?\n/).forEach(line => {
        if (line.trim()) log(line.trim());
        updateUIFromStatus(line.trim());
      });
    }

    function updateUIFromStatus(line) {
      if (!line) return;
      // Lamp state + brightness
      if (line.includes('Lamp=')) {
        const m = line.match(/Brightness=([0-9.]+)/);
        if (m) {
          const val = Math.round(parseFloat(m[1]));
          const bri = document.getElementById('bri');
          const briNum = document.getElementById('briNum');
          const briVal = document.getElementById('briVal');
          if (!Number.isNaN(val)) {
            bri.value = val;
            briVal.textContent = val;
            if (briNum) briNum.value = val;
          }
        }
        const lampState = line.match(/Lamp=([A-Z]+)/);
        const statusEl = document.getElementById('status');
        if (lampState && statusEl) statusEl.textContent = `Lamp ${lampState[1]}`;
        const lampToggle = document.getElementById('lampToggle');
        if (lampToggle && lampState) lampToggle.checked = (lampState[1] === 'ON');
      }
      // AutoCycle toggle from pattern line
      if (line.startsWith('Pattern ')) {
        const autoChk = document.getElementById('autoToggle');
        if (autoChk) autoChk.checked = line.includes('AutoCycle=ON');
        const speedMatch = line.match(/Speed=([0-9.]+)/);
        if (speedMatch) {
          const v = parseFloat(speedMatch[1]);
          const inp = document.getElementById('patSpeed');
          const num = document.getElementById('patSpeedNum');
          if (!Number.isNaN(v)) {
            if (inp) inp.value = v;
            if (num) num.value = v.toFixed(1);
          }
        }
      }
      if (line.startsWith('[Quick]')) {
        const csv = line.replace('[Quick]', '').trim();
        if (csv) {
          const parts = csv.toLowerCase() === 'none' ? [] : csv.split(',').map(x => parseInt(x.trim(), 10)).filter(n => !Number.isNaN(n));
          setQuickSelection(parts);
        }
      }
      // Presence address hint
      if (line.startsWith('Presence=')) {
        const addrMatch = line.match(/\(([^)]+)\)/);
        const input = document.getElementById('presenceMac');
        if (addrMatch && addrMatch[1] && input && !input.value) {
          input.value = addrMatch[1];
        }
        const pT = document.getElementById('presenceToggle');
        if (pT) pT.checked = line.includes('Presence=ON');
      }
      // Ramp/Idle/TouchDim
      if (line.startsWith('Ramp=')) {
        const r = line.match(/Ramp=([0-9]+)/);
        if (r) document.getElementById('rampMs').value = r[1];
        const i = line.match(/IdleOff=([0-9]+)m|IdleOff=off/);
        if (i) {
          const v = i[0].includes('off') ? 0 : parseInt(i[1]);
          document.getElementById('idleMin').value = v;
        }
        const td = document.getElementById('touchDimToggle');
        if (td) td.checked = line.includes('TouchDim=ON');
        const pf = document.getElementById('patFadeToggle');
        const pfVal = document.getElementById('patFadeVal');
        const pfAmt = document.getElementById('patFadeAmt');
        const pfNum = document.getElementById('patFadeNum');
        const m = line.match(/PatFade=([A-Z]+)\(([0-9.]+)/);
        if (pf) pf.checked = line.includes('PatFade=ON');
        if (m && pfVal && pfAmt) {
          const v = parseFloat(m[2]);
          if (!Number.isNaN(v)) {
            pfVal.textContent = v.toFixed(2);
            pfAmt.value = v;
            if (pfNum) pfNum.value = v.toFixed(2);
          }
        }
        const reOn = line.match(/RampOn=([a-zA-Z-]+)\(([0-9.]+)\)/);
        const reOff = line.match(/RampOff=([a-zA-Z-]+)\(([0-9.]+)\)/);
        const selOn = document.getElementById('rampEaseOn');
        const selOff = document.getElementById('rampEaseOff');
        const powOn = document.getElementById('rampPowOn');
        const powOff = document.getElementById('rampPowOff');
        if (reOn) {
          if (selOn) selOn.value = reOn[1].toLowerCase();
          if (powOn) powOn.value = parseFloat(reOn[2]).toFixed(2);
        }
        if (reOff) {
          if (selOff) selOff.value = reOff[1].toLowerCase();
          if (powOff) powOff.value = parseFloat(reOff[2]).toFixed(2);
        }
      }
    }

  function populateModes() {
    const sel = document.getElementById('modeSelect');
    sel.innerHTML = '';
    MODE_NAMES.forEach((name, idx) => {
      const opt = document.createElement('option');
      opt.value = (idx + 1).toString();
      opt.textContent = `${idx + 1} - ${name}`;
      sel.appendChild(opt);
    });
  }

  // --- Custom pattern editor ---
  let customPoints = [];

  function syncCustomCsvFromPoints() {
    const csv = customPoints.map(v => v.toFixed(3)).join(',');
    const area = document.getElementById('customCsv');
    if (area) area.value = csv;
  }

  function renderCustomEditor() {
    const wrap = document.getElementById('customEditor');
    if (!wrap) return;
    wrap.innerHTML = '';
    customPoints.forEach((v, idx) => {
      const row = document.createElement('div');
      row.className = 'bar-row';
      const range = document.createElement('input');
      range.type = 'range';
      range.min = '0';
      range.max = '1';
      range.step = '0.01';
      range.value = v.toFixed(2);
      const num = document.createElement('input');
      num.type = 'number';
      num.min = '0';
      num.max = '1';
      num.step = '0.01';
      num.value = v.toFixed(2);
      const del = document.createElement('button');
      del.textContent = 'X';
      del.onclick = () => {
        customPoints.splice(idx, 1);
        renderCustomEditor();
        syncCustomCsvFromPoints();
      };
      const syncVal = (nv) => {
        let val = parseFloat(nv);
        if (Number.isNaN(val)) val = 0;
        if (val < 0) val = 0;
        if (val > 1) val = 1;
        customPoints[idx] = val;
        range.value = val;
        num.value = val.toFixed(2);
        syncCustomCsvFromPoints();
      };
      range.oninput = (e) => syncVal(e.target.value);
      num.oninput = (e) => syncVal(e.target.value);
      row.appendChild(range);
      row.appendChild(num);
      row.appendChild(del);
      wrap.appendChild(row);
    });
  }

  function loadPointsFromCsv() {
    const area = document.getElementById('customCsv');
    if (!area) return;
    const csv = area.value.trim();
    if (!csv) {
      customPoints = [];
      renderCustomEditor();
      return;
    }
    const vals = csv.split(',').map(s => parseFloat(s));
    customPoints = vals.filter(v => !Number.isNaN(v)).map(v => {
      if (v < 0) return 0;
      if (v > 1) return 1;
      return v;
    });
    renderCustomEditor();
  }

    function populateGuids() {
      const rows = [
        { label: 'Service UUID', value: SERVICE },
        { label: 'Command Char', value: CMD_CHAR },
        { label: 'Status Char', value: STATUS_CHAR },
      ];
      const body = document.getElementById('guidTable');
      body.innerHTML = '';
      rows.forEach(r => {
        const tr = document.createElement('tr');
        const td1 = document.createElement('td'); td1.textContent = r.label;
        const td2 = document.createElement('td'); td2.textContent = r.value;
        const td3 = document.createElement('td');
        const btn = document.createElement('button');
        btn.className = 'copy-btn';
        btn.textContent = 'Copy';
        btn.dataset.copy = r.value;
        td3.appendChild(btn);
        tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
        body.appendChild(tr);
      });
    }

    function defaultQuickIndices() {
      const out = [];
      MODE_NAMES.forEach((name, idx) => {
        if (idx < 3) out.push(idx + 1);
        if (name.toLowerCase().includes('musik'))
          out.push(idx + 1);
      });
      return Array.from(new Set(out));
    }

    function renderQuickModes(selected = defaultQuickIndices()) {
      const wrap = document.getElementById('quickList');
      wrap.innerHTML = '';
      MODE_NAMES.forEach((name, idx) => {
        const lbl = document.createElement('label');
        lbl.className = 'quick-label';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.className = 'quickCb';
        cb.value = (idx + 1).toString();
        if (selected.includes(idx + 1)) cb.checked = true;
        lbl.appendChild(cb);
        const txt = document.createElement('span');
        txt.textContent = name;
        lbl.appendChild(txt);
        wrap.appendChild(lbl);
      });
    }

    function getQuickSelection() {
      return Array.from(document.querySelectorAll('.quickCb'))
        .filter(cb => cb.checked)
        .map(cb => parseInt(cb.value, 10))
        .filter(n => !Number.isNaN(n));
    }

    function setQuickSelection(indices) {
      const idxSet = new Set(indices);
      document.querySelectorAll('.quickCb').forEach(cb => {
        cb.checked = idxSet.size === 0 ? defaultQuickIndices().includes(parseInt(cb.value, 10)) : idxSet.has(parseInt(cb.value, 10));
      });
    }

  async function sendCmd(text) {
      lastCmdText = text;
      lastCmdTime = Date.now();
    if (serialWriter) {
      try {
        await serialWriter.write(text + "\n");
        log('> ' + text + ' (serial)');
        return;
        } catch (e) {
          log('Serial send error: ' + e);
        }
      }

      if (!cmdChar) {
        log('Not connected');
        return;
      }
      try {
        const payload = new TextEncoder().encode(text + '\n');
        await cmdChar.writeValueWithoutResponse(payload);
        log('> ' + text);
      } catch (e) {
        log('Send error: ' + e);
      }
    }

    document.getElementById('btnConnect').onclick = connect;
    document.querySelectorAll('button[data-cmd]').forEach(btn => {
      btn.onclick = () => sendCmd(btn.dataset.cmd);
    });
    document.getElementById('btnSerial').onclick = connectSerial;
    document.getElementById('btnSend').onclick = () => {
      const txt = document.getElementById('cmdInput').value.trim();
      if (txt) sendCmd(txt);
    };
    const briRange = document.getElementById('bri');
    const briNum = document.getElementById('briNum');
    const briVal = document.getElementById('briVal');
    document.getElementById('btnStatus').onclick = () => {
      const now = Date.now();
      if (lastCmdText === 'off' && now - lastCmdTime < 300) {
        setTimeout(() => sendCmd('status'), 250);
      } else {
        sendCmd('status');
      }
    };
    const syncBri = (v, send = false) => {
      if (briRange) briRange.value = v;
      if (briNum) briNum.value = v;
      if (briVal) briVal.textContent = v;
      if (send) sendCmd('bri ' + v);
    };
    if (briRange) {
      briRange.oninput = e => syncBri(e.target.value);
      briRange.onchange = e => syncBri(e.target.value, true);
    }
    if (briNum) {
      briNum.oninput = e => syncBri(e.target.value);
      briNum.onchange = e => syncBri(e.target.value, true);
    }

    document.getElementById('btnPresenceSet').onclick = () => {
      const mac = document.getElementById('presenceMac').value.trim();
      if (mac) sendCmd('presence set ' + mac);
    };
    document.getElementById('btnStatus').onclick = () => sendCmd('status');
    document.getElementById('btnCfgExport').onclick = () => sendCmd('cfg export');
    document.getElementById('modeSelect').onchange = (e) => {
      const val = e.target.value;
      if (val) sendCmd('mode ' + val);
    };
    document.getElementById('autoToggle').onchange = (e) => {
      sendCmd(e.target.checked ? 'auto on' : 'auto off');
    };
    const patSpeedEl = document.getElementById('patSpeed');
    const patSpeedNum = document.getElementById('patSpeedNum');
    const syncPatSpeed = (v, send = false) => {
      if (patSpeedEl) patSpeedEl.value = v;
      if (patSpeedNum) patSpeedNum.value = v;
      if (send) sendCmd('pat scale ' + v);
    };
    if (patSpeedEl) {
      patSpeedEl.oninput = (e) => syncPatSpeed(e.target.value);
      patSpeedEl.onchange = (e) => syncPatSpeed(e.target.value, true);
    }
    if (patSpeedNum) {
      patSpeedNum.oninput = (e) => syncPatSpeed(e.target.value);
      patSpeedNum.onchange = (e) => syncPatSpeed(e.target.value, true);
    }

    populateModes();
    renderQuickModes();
    populateGuids();
    loadPointsFromCsv();
    const tdToggle = document.getElementById('touchDimToggle');
    if (tdToggle) {
      tdToggle.onchange = (e) => sendCmd(e.target.checked ? 'touchdim on' : 'touchdim off');
    }
    const lampToggle = document.getElementById('lampToggle');
    if (lampToggle) {
      const lampHandler = (e) => sendCmd(e.target.checked ? 'on' : 'off');
      lampToggle.oninput = lampHandler;
      lampToggle.onclick = lampHandler;
    }
    const presToggle = document.getElementById('presenceToggle');
    if (presToggle) {
      presToggle.onchange = (e) => sendCmd(e.target.checked ? 'presence on' : 'presence off');
    }
    const pfToggle = document.getElementById('patFadeToggle');
    const pfAmt = document.getElementById('patFadeAmt');
    const pfVal = document.getElementById('patFadeVal');
    const pfNum = document.getElementById('patFadeNum');
    if (pfToggle) {
      pfToggle.onchange = (e) => sendCmd(e.target.checked ? 'pat fade on' : 'pat fade off');
    }
    const syncPf = (v, send = false) => {
      if (pfVal) pfVal.textContent = Number(v).toFixed(2);
      if (pfAmt) pfAmt.value = v;
      if (pfNum) pfNum.value = v;
      if (send) sendCmd('pat fade amt ' + v);
    };
    if (pfAmt) {
      pfAmt.oninput = (e) => syncPf(e.target.value);
      pfAmt.onchange = (e) => syncPf(e.target.value, true);
      syncPf(pfAmt.value);
    }
    if (pfNum) {
      pfNum.oninput = (e) => syncPf(e.target.value);
      pfNum.onchange = (e) => syncPf(e.target.value, true);
    }
    const rampEaseOn = document.getElementById('rampEaseOn');
    const rampEaseOff = document.getElementById('rampEaseOff');
    const rampPowOn = document.getElementById('rampPowOn');
    const rampPowOff = document.getElementById('rampPowOff');
    if (rampEaseOn) rampEaseOn.onchange = () => sendCmd(`ramp ease on ${rampEaseOn.value} ${rampPowOn ? rampPowOn.value : ''}`);
    if (rampPowOn) rampPowOn.onchange = () => sendCmd(`ramp ease on ${rampEaseOn ? rampEaseOn.value : 'ease'} ${rampPowOn.value}`);
    if (rampEaseOff) rampEaseOff.onchange = () => sendCmd(`ramp ease off ${rampEaseOff.value} ${rampPowOff ? rampPowOff.value : ''}`);
    if (rampPowOff) rampPowOff.onchange = () => sendCmd(`ramp ease off ${rampEaseOff ? rampEaseOff.value : 'ease'} ${rampPowOff.value}`);
    document.getElementById('btnQuickApply').onclick = () => {
      const sel = getQuickSelection();
      sendCmd(sel.length ? ('quick ' + sel.join(',')) : 'quick default');
    };
    document.getElementById('btnTouchHold').onclick = () => {
      const v = document.getElementById('touchHold').value;
      sendCmd('touch hold ' + v);
    };
    document.getElementById('btnRamp').onclick = () => {
      const v = document.getElementById('rampMs').value;
      sendCmd('ramp ' + v);
    };
    document.getElementById('btnIdle').onclick = () => {
      const v = document.getElementById('idleMin').value;
      sendCmd('idle ' + v);
    };
    document.getElementById('btnCustomStep').onclick = () => {
      const v = document.getElementById('customStep').value;
      sendCmd('custom step ' + v);
    };
    const btnCustomSend = document.getElementById('btnCustomSend');
    if (btnCustomSend) {
      btnCustomSend.onclick = () => {
        syncCustomCsvFromPoints();
        const csv = document.getElementById('customCsv').value.trim();
        if (csv) sendCmd('custom ' + csv);
      };
    }
    const btnCustomAdd = document.getElementById('btnCustomAdd');
    if (btnCustomAdd) {
      btnCustomAdd.onclick = () => {
        customPoints.push(0.5);
        renderCustomEditor();
        syncCustomCsvFromPoints();
      };
    }
    const btnCustomClear = document.getElementById('btnCustomClear');
    if (btnCustomClear) {
      btnCustomClear.onclick = () => {
        customPoints = [];
        renderCustomEditor();
        syncCustomCsvFromPoints();
      };
    }
    const customCsvArea = document.getElementById('customCsv');
    if (customCsvArea) {
      customCsvArea.onchange = loadPointsFromCsv;
    }
    document.getElementById('btnExport').onclick = () => sendCmd('cfg export');
    document.getElementById('btnImport').onclick = () => {
      const cfg = document.getElementById('importArea').value.trim();
      if (cfg) sendCmd(cfg.startsWith('cfg import') ? cfg : ('cfg import ' + cfg));
    };

    document.getElementById('btnTouchTune').onclick = () => {
      const on = document.getElementById('touchOn').value;
      const off = document.getElementById('touchOff').value;
      sendCmd(`touch tune ${on} ${off}`);
    };
    const btnTouchTuneOff = document.getElementById('btnTouchTuneOff');
    if (btnTouchTuneOff) {
      btnTouchTuneOff.onclick = () => {
        const on = document.getElementById('touchOn').value;
        const off = document.getElementById('touchOff').value;
        sendCmd(`touch tune ${on} ${off}`);
      };
    }
    document.getElementById('btnCalibTouch').onclick = () => sendCmd('calibrate touch');
    document.getElementById('btnCalib').onclick = () => sendCmd('calibrate');

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').then(() => {
          log('Service worker registered');
        }).catch((e) => log('SW register failed: ' + e));
      });
    }
    // Copy GUIDs
    document.body.addEventListener('click', (e) => {
      const target = e.target;
      if (target && target.dataset && target.dataset.copy) {
        const txt = target.dataset.copy;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(txt).then(() => log('Copied: ' + txt)).catch(() => log('Copy failed'));
        } else {
          log('Clipboard not available');
        }
      }
    });
  </script>
</body>
</html>
