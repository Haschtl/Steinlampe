<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quarzlampe Web BLE</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: #11182a;
      --border: #1f2b44;
      --accent: #5be6ff;
      --accent2: #8cf59b;
      --text: #eef2ff;
      --muted: #9fb2cc;
    }
    * { box-sizing: border-box; }
    body { font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif; margin: 0; background: radial-gradient(circle at 20% 20%, #111a2d, #0b0f1a 50%), #0b0f1a; color: var(--text); padding: 1.2rem; }
    h1 { margin: 0 0 0.6rem; letter-spacing: 0.02em; }
    h3 { margin-top: 0; color: var(--accent); }
    button, input, textarea { margin: 0.15rem; padding: 0.45rem 0.65rem; border-radius: 6px; border: 1px solid var(--border); background: #0f1525; color: var(--text); }
    button { cursor: pointer; transition: all 0.15s ease; }
    button:hover { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 0 1px #1a2438; }
    input, textarea { background: #0d1322; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1rem; }
    .card { border: 1px solid var(--border); padding: 0.85rem; border-radius: 10px; background: linear-gradient(145deg, rgba(255,255,255,0.02), rgba(0,0,0,0.2)); box-shadow: 0 5px 25px rgba(0,0,0,0.35); }
    #log { width: 100%; height: 220px; background:#0b0f1a; color: #8ce5ff; padding: 0.6rem; overflow-y: auto; font-family: 'SFMono-Regular', Menlo, monospace; border:1px solid var(--border); border-radius:8px; }
    label { display:block; margin-top:0.35rem; font-size: 0.9rem; color: var(--muted); }
    .row { display:flex; flex-wrap:wrap; gap:0.4rem; align-items:center; }
    .pill { padding: 0.35rem 0.6rem; border-radius: 999px; background: #10172a; border:1px solid var(--border); color: var(--muted); font-size: 0.9rem; }
    .header { display:flex; gap:0.75rem; align-items:center; margin-bottom: 0.75rem; }
    #status { color: var(--accent2); }
    textarea { resize: vertical; }
  </style>
</head>
<body>
  <div class="header">
    <h1>Quarzlampe Web BLE</h1>
    <button id="btnConnect">Connect</button>
    <button id="btnSerial">Connect Serial</button>
    <button id="btnStatus">Status</button>
    <button id="btnCfgExport">cfg export</button>
    <label class="pill" style="cursor:pointer;">
      <input type="checkbox" id="autoReconnect" style="margin-right:0.35rem;" checked />Auto-reconnect
    </label>
    <span class="pill" id="status">Not connected</span>
    <a class="pill" href="https://github.com/Haschtl/Steinlampe/actions/workflows/ci.yml" target="_blank" rel="noopener">Firmware Build (Actions)</a>
  </div>

  <div class="grid">
    <div class="card">
      <h3>Lamp</h3>
      <div class="row">
        <button data-cmd="on">On</button>
        <button data-cmd="off">Off</button>
        <button data-cmd="toggle">Toggle</button>
      </div>
      <div class="row">
        <button data-cmd="prev">Prev</button>
        <select id="modeSelect" style="min-width:170px;"></select>
        <button data-cmd="next">Next</button>
      </div>
      <div class="row">
        <label class="pill" style="cursor:pointer;">
          <input type="checkbox" id="autoToggle" style="margin-right:0.35rem;" />AutoCycle
        </label>
      </div>
      <label>Brightness: <span id="briVal">--</span>%</label>
      <input id="bri" type="range" min="1" max="100" value="70" />
    </div>

    <div class="card">
      <h3>Presence</h3>
      <div class="row">
        <input id="presenceMac" type="text" placeholder="AA:BB:CC:DD:EE:FF" size="20" />
        <button id="btnPresenceSet">Set</button>
        <button data-cmd="presence clear">Clear</button>
      </div>
      <div class="row">
        <button data-cmd="presence on">Presence On</button>
        <button data-cmd="presence off">Presence Off</button>
      </div>
    </div>

    <div class="card">
      <h3>Touch / Ramps</h3>
      <div class="row">
        <label>Touch hold (ms)</label>
        <input id="touchHold" type="number" min="500" max="5000" step="100" value="1000" />
        <button id="btnTouchHold">Set</button>
      </div>
      <div class="row">
        <label>Ramp (ms)</label>
        <input id="rampMs" type="number" min="50" max="5000" step="50" value="400" />
        <button id="btnRamp">Set</button>
      </div>
      <div class="row">
        <label>IdleOff (min, 0=off)</label>
        <input id="idleMin" type="number" min="0" max="180" step="1" value="0" />
        <button id="btnIdle">Set</button>
      </div>
    </div>

    <div class="card">
      <h3>Custom</h3>
      <div class="row">
        <input id="customStep" type="number" min="100" max="5000" step="50" value="800" />
        <button id="btnCustomStep">Set Step</button>
      </div>
      <label>CSV values (0..1)</label>
      <textarea id="customCsv" rows="4" style="width:100%;"></textarea>
      <button id="btnCustomSend">Send Custom</button>
    </div>

    <div class="card">
      <h3>Raw Command</h3>
      <div class="row">
        <input id="cmdInput" type="text" placeholder="type command" size="28" />
        <button id="btnSend">Send</button>
        <button id="btnExport">cfg export</button>
      </div>
      <div class="row">
        <textarea id="importArea" rows="3" style="width:100%;" placeholder="paste cfg export here"></textarea>
        <button id="btnImport">Import cfg</button>
      </div>
    </div>
  </div>

  <h3>Log</h3>
  <pre id="log"></pre>

  <script>
    const SERVICE = 'd94d86d7-1eaf-47a4-9d1e-7a90bf34e66b';
    const CMD_CHAR = '4bb5047d-0d8b-4c5e-81cd-6fb5c0d1d1f7';
    const STATUS_CHAR = 'c5ad78b6-9b77-4a96-9a42-8e6e9a40c123';
    const MODE_NAMES = [
      'Konstant', 'Atmung', 'Pulsierend', 'Funkeln', 'Kerze',
      'Lagerfeuer', 'Stufen', 'Zwinkern', 'Custom', 'Musik'
    ];

    let cmdChar = null;
    let statusChar = null;
    let device = null;
    let reconnecting = false;
    let serialPort = null;
    let serialWriter = null;
    let serialReader = null;

    const logEl = document.getElementById('log');
    function log(msg) {
      const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      logEl.textContent += line;
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function connect() {
      if (!navigator.bluetooth) {
        log('Web Bluetooth not supported or not available (needs Chrome/Edge over HTTPS/localhost; enable chrome://flags/#enable-experimental-web-platform-features on some platforms).');
        return;
      }
      try {
        let reqOpts = { filters: [{ services: [SERVICE] }], optionalServices: [SERVICE] };
        try {
          device = await navigator.bluetooth.requestDevice(reqOpts);
        } catch (e1) {
          log('Filter request failed, trying acceptAllDevices...');
          device = await navigator.bluetooth.requestDevice({ acceptAllDevices: true, optionalServices: [SERVICE] });
        }

        log('Connecting...');
        const server = await device.gatt.connect();
        device.addEventListener('gattserverdisconnected', async () => {
          log('Disconnected');
          document.getElementById('status').textContent = 'Disconnected';
          if (document.getElementById('autoReconnect').checked && device) {
            reconnecting = true;
            try {
              log('Reconnecting...');
              await device.gatt.connect();
              log('Reconnected');
              document.getElementById('status').textContent = 'Connected to ' + device.name;
            } catch (e) {
              log('Reconnect failed: ' + e);
            } finally {
              reconnecting = false;
            }
          }
        });
        log('Discover service');
        const service = await server.getPrimaryService(SERVICE);

        // List available characteristics for debugging
        try {
          const chars = await service.getCharacteristics();
          log('Found chars: ' + chars.map(c => c.uuid).join(', '));
        } catch (e) {
          log('Could not list characteristics: ' + e);
        }

        log('Discover cmd/status chars');
        try {
          cmdChar = await service.getCharacteristic(CMD_CHAR);
        } catch (e) {
          log('Cmd char not found: ' + e);
          throw e;
        }
        try {
          statusChar = await service.getCharacteristic(STATUS_CHAR);
        } catch (e) {
          log('Status char not found: ' + e);
          throw e;
        }

        let notified = false;
        // Attach notifications on cmdChar (firmware sends feedback here)
        if (cmdChar && cmdChar.properties && cmdChar.properties.notify) {
          try {
            await cmdChar.startNotifications();
            cmdChar.addEventListener('characteristicvaluechanged', onNotify);
            log('Cmd notify enabled');
          } catch (e) {
            log('Cmd notify not available: ' + e);
          }
        }

        // Attach notifications on statusChar
        if (statusChar && statusChar.properties && statusChar.properties.notify) {
          try {
            await statusChar.startNotifications();
            statusChar.addEventListener('characteristicvaluechanged', onNotify);
            log('Status notify enabled');
            notified = true;
          } catch (e) {
            log('Status notify not available; using read fallback');
          }
        } else {
          log('Status notify not supported by firmware');
        }

        if (statusChar && !notified) {
          try {
            const val = await statusChar.readValue();
            onNotify({ target: { value: val } });
          } catch (e2) {
            log('Status read failed: ' + e2);
          }
        }
        document.getElementById('status').textContent = 'Connected to ' + device.name;
        log('Connected to ' + device.name);
      } catch (e) {
        log('Connect error: ' + e);
      }
    }

    async function connectSerial() {
      if (!('serial' in navigator)) {
        log('Web Serial not supported (needs Chrome/Edge over HTTPS/localhost)');
        return;
      }
      try {
        serialPort = await navigator.serial.requestPort();
        await serialPort.open({ baudRate: 115200 });
        const encoder = new TextEncoderStream();
        serialWriter = encoder.writable.getWriter();
        encoder.readable.pipeTo(serialPort.writable);

        const reader = serialPort.readable.getReader();
        const decoder = new TextDecoder();
        serialReader = reader;
        let buffer = '';
        log('Serial connected');
        document.getElementById('status').textContent = 'Serial connected';
        (async () => {
          try {
            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              buffer += decoder.decode(value, { stream: true });
              let idx;
              while ((idx = buffer.indexOf('\n')) >= 0) {
                const line = buffer.slice(0, idx).trim();
                buffer = buffer.slice(idx + 1);
                if (line) {
                  log(line);
                  onNotify({ target: { value: new TextEncoder().encode(line) } });
                }
              }
            }
          } catch (e) {
            log('Serial read error: ' + e);
          } finally {
            reader.releaseLock();
            serialReader = null;
            serialWriter = null;
            if (serialPort) await serialPort.close();
            serialPort = null;
            document.getElementById('status').textContent = 'Disconnected';
          }
        })();
      } catch (e) {
        log('Serial connect error: ' + e);
      }
    }

    function onNotify(e) {
      const txt = new TextDecoder().decode(e.target.value || new DataView());
      txt.split(/\r?\n/).forEach(line => {
        if (line.trim()) log(line.trim());
        updateUIFromStatus(line.trim());
      });
    }

    function updateUIFromStatus(line) {
      if (!line) return;
      // Lamp state + brightness
      if (line.includes('Lamp=')) {
        const m = line.match(/Brightness=([0-9.]+)/);
        if (m) {
          const val = Math.round(parseFloat(m[1]));
          const bri = document.getElementById('bri');
          const briVal = document.getElementById('briVal');
          if (!Number.isNaN(val)) {
            bri.value = val;
            briVal.textContent = val;
          }
        }
        const lampState = line.match(/Lamp=([A-Z]+)/);
        const statusEl = document.getElementById('status');
        if (lampState && statusEl) statusEl.textContent = `Lamp ${lampState[1]}`;
      }
      // AutoCycle toggle from pattern line
      if (line.startsWith('Pattern ')) {
        const autoChk = document.getElementById('autoToggle');
        if (autoChk) autoChk.checked = line.includes('AutoCycle=ON');
      }
      // Presence address hint
      if (line.startsWith('Presence=')) {
        const addrMatch = line.match(/\(([^)]+)\)/);
        const input = document.getElementById('presenceMac');
        if (addrMatch && addrMatch[1] && input && !input.value) {
          input.value = addrMatch[1];
        }
      }
      // Ramp/Idle/TouchDim
      if (line.startsWith('Ramp=')) {
        const r = line.match(/Ramp=([0-9]+)/);
        if (r) document.getElementById('rampMs').value = r[1];
        const i = line.match(/IdleOff=([0-9]+)m|IdleOff=off/);
        if (i) {
          const v = i[0].includes('off') ? 0 : parseInt(i[1]);
          document.getElementById('idleMin').value = v;
        }
        if (line.includes('TouchDim=ON')) {
          // nothing to toggle here, but could reflect state visually later
        }
      }
    }

    function populateModes() {
      const sel = document.getElementById('modeSelect');
      sel.innerHTML = '';
      MODE_NAMES.forEach((name, idx) => {
        const opt = document.createElement('option');
        opt.value = (idx + 1).toString();
        opt.textContent = `${idx + 1} - ${name}`;
        sel.appendChild(opt);
      });
    }

    async function sendCmd(text) {
      if (serialWriter) {
        try {
          await serialWriter.write(text + "\n");
          log('> ' + text + ' (serial)');
          return;
        } catch (e) {
          log('Serial send error: ' + e);
        }
      }

      if (!cmdChar) {
        log('Not connected');
        return;
      }
      try {
        const payload = new TextEncoder().encode(text + '\n');
        await cmdChar.writeValueWithoutResponse(payload);
        log('> ' + text);
      } catch (e) {
        log('Send error: ' + e);
      }
    }

    document.getElementById('btnConnect').onclick = connect;
    document.querySelectorAll('button[data-cmd]').forEach(btn => {
      btn.onclick = () => sendCmd(btn.dataset.cmd);
    });
    document.getElementById('btnSerial').onclick = connectSerial;
    document.getElementById('btnSend').onclick = () => {
      const txt = document.getElementById('cmdInput').value.trim();
      if (txt) sendCmd(txt);
    };
    document.getElementById('bri').oninput = e => {
      document.getElementById('briVal').textContent = e.target.value;
    };
    document.getElementById('bri').onchange = e => sendCmd('bri ' + e.target.value);

    document.getElementById('btnPresenceSet').onclick = () => {
      const mac = document.getElementById('presenceMac').value.trim();
      if (mac) sendCmd('presence set ' + mac);
    };
    document.getElementById('btnStatus').onclick = () => sendCmd('status');
    document.getElementById('btnCfgExport').onclick = () => sendCmd('cfg export');
    document.getElementById('modeSelect').onchange = (e) => {
      const val = e.target.value;
      if (val) sendCmd('mode ' + val);
    };
    document.getElementById('autoToggle').onchange = (e) => {
      sendCmd(e.target.checked ? 'auto on' : 'auto off');
    };

    populateModes();
    document.getElementById('btnTouchHold').onclick = () => {
      const v = document.getElementById('touchHold').value;
      sendCmd('touch hold ' + v);
    };
    document.getElementById('btnRamp').onclick = () => {
      const v = document.getElementById('rampMs').value;
      sendCmd('ramp ' + v);
    };
    document.getElementById('btnIdle').onclick = () => {
      const v = document.getElementById('idleMin').value;
      sendCmd('idle ' + v);
    };
    document.getElementById('btnCustomStep').onclick = () => {
      const v = document.getElementById('customStep').value;
      sendCmd('custom step ' + v);
    };
    document.getElementById('btnCustomSend').onclick = () => {
      const csv = document.getElementById('customCsv').value.trim();
      if (csv) sendCmd('custom ' + csv);
    };
    document.getElementById('btnExport').onclick = () => sendCmd('cfg export');
    document.getElementById('btnImport').onclick = () => {
      const cfg = document.getElementById('importArea').value.trim();
      if (cfg) sendCmd(cfg.startsWith('cfg import') ? cfg : ('cfg import ' + cfg));
    };
  </script>
</body>
</html>
