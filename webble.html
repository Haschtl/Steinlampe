<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#0b0f1a" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/svg+xml" href="icon-lamp.svg" />
  <title>Quarzlampe</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: #11182a;
      --border: #1f2b44;
      --accent: #5be6ff;
      --accent2: #8cf59b;
      --text: #eef2ff;
      --muted: #9fb2cc;
    }
    * { box-sizing: border-box; }
    body { font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif; margin: 0; background: radial-gradient(circle at 20% 20%, #111a2d, #0b0f1a 50%), #0b0f1a; color: var(--text); padding: 1.2rem; }
    h1 { margin: 0 0 0.6rem; letter-spacing: 0.02em; }
    h3 { margin-top: 0; color: var(--accent); }
    button, input, textarea { margin: 0.15rem; padding: 0.45rem 0.65rem; border-radius: 6px; border: 1px solid var(--border); background: #0f1525; color: var(--text); }
    button { cursor: pointer; transition: all 0.15s ease; }
    button:hover { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 0 1px #1a2438; }
    input, textarea { background: #0d1322; }
    select { background:#0f1525; color:var(--text); border:1px solid var(--border); border-radius:8px; padding:0.5rem 0.75rem; min-width:170px; appearance:none; -moz-appearance:none; -webkit-appearance:none; background-image: linear-gradient(45deg, transparent 50%, var(--accent) 50%), linear-gradient(135deg, var(--accent) 50%, transparent 50%); background-position: right 12px top 55%, right 6px top 55%; background-size: 10px 10px, 10px 10px; background-repeat: no-repeat; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1rem; }
    .card { border: 1px solid var(--border); padding: 0.85rem; border-radius: 10px; background: linear-gradient(145deg, rgba(255,255,255,0.02), rgba(0,0,0,0.2)); box-shadow: 0 5px 25px rgba(0,0,0,0.35); }
    #log { width: 100%; height: 220px; background:#0b0f1a; color: #8ce5ff; padding: 0.6rem; overflow-y: auto; font-family: 'SFMono-Regular', Menlo, monospace; border:1px solid var(--border); border-radius:8px; }
    .log-block { border:1px solid var(--border); border-radius:10px; overflow:hidden; background:#0b0f1a; box-shadow: 0 4px 20px rgba(0,0,0,0.25); }
    .log-block #log { border:none; border-bottom:1px solid var(--border); border-radius:0; margin:0; }
    .log-row { background:#0d1322; padding:0.5rem; }
    label { display:block; margin-top:0.35rem; font-size: 0.9rem; color: var(--muted); }
    .sr-only { position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
    .row { display:flex; flex-wrap:wrap; gap:0.4rem; align-items:center; }
    .pill { padding: 0.35rem 0.6rem; border-radius: 999px; background: #10172a; border:1px solid var(--border); color: var(--muted); font-size: 0.9rem; }
    .header { display:flex; gap:0.75rem; align-items:center; margin-bottom: 0.75rem; flex-wrap: wrap; }
    .header .pill, .header button { flex-shrink: 0; }
    #status { color: var(--accent2); }
    textarea { resize: vertical; }
    #quickList { display:grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap:0.45rem; align-items:start; width:100%; }
    .quick-label { display:flex; align-items:center; gap:0.35rem; padding:0.38rem 0.55rem; border:1px solid var(--border); border-radius:8px; background:#0d1322; color:var(--text); width:100%; }
    .quick-label input { accent-color: var(--accent); }
    table.info-table { width:100%; border-collapse: collapse; margin-top:0.5rem; }
    table.info-table th, table.info-table td { border:1px solid var(--border); padding:0.45rem 0.55rem; text-align:left; }
    table.info-table th { background:#10172a; color:var(--accent); }
    table.info-table tbody tr:nth-child(even) { background:#0d1322; }
    .copy-btn { padding:0.3rem 0.5rem; border-radius:6px; border:1px solid var(--border); background:#0f1525; color:var(--text); cursor:pointer; }
    .input-group { display:flex; align-items:stretch; gap:0; width:100%; position:relative; overflow:visible; }
    .input-group input,
    .input-group textarea { border-top-right-radius:0; border-bottom-right-radius:0; margin-right:0; flex:1; min-width:0; }
    .input-group button { border-top-left-radius:0; border-bottom-left-radius:0; margin-left:0; margin-right:0; }
    .input-suffix { color: var(--muted); font-size:0.9rem; margin-left:0.25rem; white-space:nowrap; display:flex; align-items:center; }
    .input-group .input-suffix { margin:0 0.4rem; }
    .slider-group { margin:0.35rem 0; }
    .slider-top { display:flex; justify-content:space-between; align-items:center; gap:0.6rem; color:var(--muted); }
    .slider-number { width:90px; text-align:right; }
    .slider-row { display:flex; gap:0.6rem; align-items:center; }
    .slider-row input[type=range] { flex:1; accent-color: var(--accent); height: 14px; border-radius: 999px; background: linear-gradient(90deg, rgba(91,230,255,0.4) 0%, rgba(88,129,255,0.2) 100%); }
    .slider-row input[type=range]::-webkit-slider-thumb { width:22px; height:22px; border-radius:50%; background: #0b0f1a; border:2px solid var(--accent); box-shadow: 0 6px 14px rgba(0,0,0,0.4); }
    .slider-row input[type=range]::-moz-range-thumb { width:22px; height:22px; border-radius:50%; background: #0b0f1a; border:2px solid var(--accent); box-shadow: 0 6px 14px rgba(0,0,0,0.4); }
    .bar-row { display:flex; align-items:center; gap:0.6rem; margin:0.25rem 0; }
    .bar-row input[type=range] { flex:1; accent-color: var(--accent2); }
    .bar-row input[type=number] { width:80px; text-align:right; }
    .bar-row button { padding:0.3rem 0.6rem; }
    .dropdown { position:relative; }
    .dropdown-menu { display:none; position:absolute; top:110%; right:0; background:#0d1322; border:1px solid var(--border); border-radius:10px; padding:0.5rem; min-width:210px; box-shadow:0 10px 25px rgba(0,0,0,0.35); z-index:20; }
    .dropdown.open .dropdown-menu { display:block; }
    .dropdown-menu .row { margin:0.15rem 0; }
    .ramp-preview { width:100%; height:70px; border:1px solid var(--border); border-radius:8px; background:#0d1322; }
    .status-chip { padding:0.35rem 0.6rem; border-radius:999px; border:1px solid var(--border); background:#0d1322; color:var(--muted); }
    .header { position: sticky; top: 0; z-index: 5; padding:0.4rem 0 0.8rem; background: radial-gradient(circle at 20% 20%, #111a2d, #0b0f1a 50%), #0b0f1a; }
    .lamp-ramps-grid { grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:1rem; margin-top:0.6rem; align-items:stretch; }
    .lamp-ramps-card { margin:0; display:flex; flex-direction:column; }
    .hint { color: var(--muted); font-size:0.92rem; margin:0.1rem 0 0.4rem; }
    @media (max-width: 760px) {
      .lamp-ramps-grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="header">
    <img src="icon-lamp.svg" alt="Lamp Icon" style="width:40px; height:40px; border-radius:8px; border:1px solid var(--border); background:#0b0f1a; padding:4px;" />
    <h1>Quarzlampe</h1>
    <button id="btnConnect">Connect</button>
    <button id="btnSerial">Connect Serial</button>
    <label class="pill" style="cursor:pointer;">
      <input type="checkbox" id="autoReconnect" style="margin-right:0.35rem;" checked />Auto-reconnect
    </label>
    <span class="pill" id="status">Not connected</span>
    <span class="pill" id="lastStatus">Last status: --</span>
  </div>
  <div class="main" style="display: flex; flex-wrap: wrap; gap: 1rem;">

  <div class="grid" style="flex:3;">
    <div class="card" style="grid-column: span 2; flex: 1;">
      <div style="display:flex; align-items:center; justify-content:space-between; gap:0.8rem; flex-wrap:wrap;">
        <h3 style="margin:0;">Lamp & Ramps</h3>
        <div class="row" style="gap:0.4rem; align-items:center; flex-wrap:wrap;">
          <label>Profile</label>
          <select id="profileSlotInline">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
          </select>
          <button id="btnProfileLoadInline">Load</button>
          <button id="btnProfileSaveInline">Save</button>
        </div>
      </div>
      <div class="grid lamp-ramps-grid">
        <div class="card lamp-ramps-card">
          <h3 style="display:flex; align-items:center; gap:0.6rem; justify-content:space-between;">
            <span>Lamp</span>
            <div class="row" style="gap:0.3rem; align-items:center; margin:0;">
              <label class="pill" style="cursor:pointer; margin:0;">
                <input type="checkbox" id="lampToggle" style="margin-right:0.35rem;" />On
              </label>
            </div>
          </h3>
          <div class="slider-group">
            <div class="slider-top">
              <span>Brightness</span>
              <div style="display:flex; gap:0.35rem; align-items:center;">
                <label class="sr-only" for="briNum">Brightness value</label>
                <input id="briNum" class="slider-number" type="number" min="1" max="100" step="1" value="70" />
                <span class="input-suffix">%</span>
                <span id="briVal" style="display:none;">70</span>
              </div>
            </div>
            <div class="slider-row">
              <label class="sr-only" for="bri">Brightness slider</label>
              <input id="bri" type="range" min="1" max="100" value="70" />
            </div>
          </div>
          <div class="row">
            <span class="status-chip">Switch: <span id="switchState">--</span></span>
            <span class="status-chip">Touch: <span id="touchState">--</span></span>
            <button data-cmd="sync" title="Align lamp state to physical switch">Sync</button>
          </div>
          <div class="input-group" style="max-width: 100%;">
            <button data-cmd="prev" style="border-radius:6px 0 0 6px;">Prev</button>
            <select id="modeSelect" style="min-width:170px; border-radius:0; margin:0; height:100%; margin-top: 0.125rem; padding-top:0.5rem; padding-bottom:0.35rem;"></select>
            <button data-cmd="next" style="border-radius:0 6px 6px 0;">Next</button>
          </div>
          <div class="row">
            <label class="pill" style="cursor:pointer;">
              <input type="checkbox" id="autoToggle" style="margin-right:0.35rem;" />AutoCycle
            </label>

            <label class="pill" style="cursor:pointer;">
              <input type="checkbox" id="patFadeToggle" style="margin-right:0.35rem;" />Pattern Fade
            </label>
          </div>
          <div class="slider-group">
            <p class="hint" style="margin-top:0;">Speed acts as speed-multiplier for the active pattern.</p>
            <div class="slider-top">
              <span>Speed</span>
              <label class="sr-only" for="patSpeedNum">Pattern speed value</label>
              <div style="display:flex; align-items:center; gap:0.3rem;">
                <input id="patSpeedNum" class="slider-number" type="number" min="0.1" max="5" step="0.1" value="1.0" />
                <span class="input-suffix">x</span>
              </div>
            </div>
            <div class="slider-row">
              <label class="sr-only" for="patSpeed">Pattern speed slider</label>
              <input id="patSpeed" type="range" min="0.1" max="5" step="0.1" value="1.0" />
            </div>
          </div>

          <div class="slider-group">
                 <p class="hint" style="margin-top:0;">Fade is a smoothing factor for the active patterh.</p>

            <div class="slider-top">
              <span>Fade</span>
              <label class="sr-only" for="patFadeNum">Pattern fade value</label>
              <div style="display:flex; align-items:center; gap:0.3rem;">
                <input id="patFadeNum" class="slider-number" type="number" min="0.01" max="5" step="0.01" value="1.00" />
                <span class="input-suffix">x</span>
              </div>
            </div>
            <div class="slider-row">
              <label class="sr-only" for="patFadeAmt">Pattern fade slider</label>
              <input id="patFadeAmt" type="range" min="0.01" max="5" step="0.01" value="1.00" />
            </div>
          </div>
        </div>

        <div class="card lamp-ramps-card">
          <h3>Ramps</h3>
          <p class="hint" style="margin-top:0;">Choose easing and power multipliers for on/off transitions and PWM curve shaping.</p>
          <div class="row" style="flex-wrap:wrap; gap:0.6rem;">
            <div style="flex:1; min-width:240px; border:1px solid var(--border); border-radius:10px; padding:0.6rem; background:#0d1322;">
              <div class="slider-top" style="margin-bottom:0.25rem;">
                <span>PWM Curve</span>
                <label class="sr-only" for="pwmCurveNum">PWM curve value</label>
                <div style="display:flex; align-items:center; gap:0.3rem;">
                  <input id="pwmCurveNum" class="slider-number" type="number" min="0.5" max="4" step="0.05" value="2.20" />
                  <span class="input-suffix">x</span>
                </div>
              </div>
              <div class="slider-row">
                <label class="sr-only" for="pwmCurve">PWM curve slider</label>
                <input id="pwmCurve" type="range" min="0.5" max="4" step="0.05" value="2.20" />
              </div>
            </div>
          </div>
          <div class="row" style="flex-wrap:wrap; gap:0.6rem;">
            <div style="flex:1; min-width:240px; border:1px solid var(--border); border-radius:10px; padding:0.6rem; background:#0d1322;">
              <label>Ramp On</label>
              <div class="row" style="gap:0.4rem; align-items:center;">
                <select id="rampEaseOn">
                  <option value="linear">linear</option>
                  <option value="ease">ease</option>
                  <option value="ease-in">ease-in</option>
                  <option value="ease-out">ease-out</option>
                  <option value="ease-in-out">ease-in-out</option>
                </select>
                <label class="sr-only" for="rampPowOn">Ramp on power</label>
                <div style="display:flex; align-items:center; gap:0.3rem;">
                  <input id="rampPowOn" type="number" min="0.01" max="10" step="0.01" value="2.0"  />
                  <span class="input-suffix">x</span>
                </div>
              </div>
              <div class="slider-row" style="margin-top:0.25rem;">
                <label class="sr-only" for="rampPowOnRange">Ramp on power slider</label>
                <input id="rampPowOnRange" type="range" min="0.01" max="10" step="0.01" value="2.0" />
              </div>
              <svg id="rampPrevOn" class="ramp-preview" viewBox="0 0 100 50" style="margin-top:0.35rem;"></svg>
              </div>
            </div>
            <div style="flex:1; min-width:240px; border:1px solid var(--border); border-radius:10px; padding:0.6rem; background:#0d1322;">
              <label>Ramp Off</label>
              <div class="row" style="gap:0.4rem; align-items:center;">
                <select id="rampEaseOff">
                  <option value="linear">linear</option>
                  <option value="ease">ease</option>
                  <option value="ease-in">ease-in</option>
                  <option value="ease-out">ease-out</option>
                  <option value="ease-in-out">ease-in-out</option>
                </select>
                <label class="sr-only" for="rampPowOff">Ramp off power</label>
                <div style="display:flex; align-items:center; gap:0.3rem;">
                  <input id="rampPowOff" type="number" min="0.01" max="10" step="0.01" value="2.0"  />
                  <span class="input-suffix">x</span>
                </div>
              </div>
              <div class="slider-row" style="margin-top:0.25rem;">
                <label class="sr-only" for="rampPowOffRange">Ramp off power slider</label>
                <input id="rampPowOffRange" type="range" min="0.01" max="10" step="0.01" value="2.0" />
              </div>
              <svg id="rampPrevOff" class="ramp-preview" viewBox="0 0 100 50" style="margin-top:0.35rem;"></svg>
              </div>
            </div>
          </div>
        </div>
    </div>

    <div class="card"  style="flex:1;">
      <h3>Notify</h3>
      <div class="row">
        <div class="input-group" style="flex-wrap:wrap; align-items:center;">
          <label class="sr-only" for="notifySeq">Notify sequence</label>
          <div style="display:flex; align-items:center; gap:0.35rem; flex:1; min-width:200px;">
            <input id="notifySeq" type="text" placeholder="80 40 80 120" />
            <span class="input-suffix">ms list</span>
          </div>
          <div class="dropdown" id="notifyDropdown" style="margin-left:0.35rem;">
            <button id="notifyOptsToggle" type="button">Optionen</button>
            <div class="dropdown-menu" id="notifyOptsMenu">
              <div class="row" style="flex-direction:column; gap:0.25rem;">
                <label for="notifyFade">Fade (dt)</label>
                <div style="display:flex; align-items:center; gap:0.35rem;">
                  <label class="sr-only" for="notifyFade">Notify fade</label>
                  <input id="notifyFade" type="number" min="0" max="200" step="10" value="0" style="width:90px;" />
                  <span class="input-suffix">ms</span>
                </div>
              </div>
              <div class="row" style="flex-direction:column; gap:0.25rem;">
                <label for="notifyRepeat">Multiplikator</label>
                <div style="display:flex; align-items:center; gap:0.35rem;">
                  <label class="sr-only" for="notifyRepeat">Notify repeat count</label>
                  <input id="notifyRepeat" type="number" min="1" max="10" step="1" value="1" style="width:90px;" />
                  <span class="input-suffix">x</span>
                </div>
              </div>
            </div>
          </div>
          <button id="btnNotify">Notify</button>
          <button id="btnNotifyStop">Stop</button>
        </div>
      </div>
      <div class="row" style="gap:0.35rem; flex-wrap:wrap;">
        <button class="notifyPreset" data-seq="80 40 80 120" data-fade="0">Short blink</button>
        <button class="notifyPreset" data-seq="200 100" data-fade="100">Soft alert</button>
        <button class="notifyPreset" data-seq="120 80 120 80 120 200" data-fade="40">Triple pulse</button>
        <button class="notifyPreset" data-seq="200 80 200 400" data-fade="30">Doorbell</button>
        <button class="notifyPreset" data-seq="500 300" data-fade="120">Long Fade Alert</button>
        <button class="notifyPreset" data-seq="60 60 60 200" data-fade="0">Double 60</button>
      </div>
      <p style="color:var(--muted); margin:0.2rem 0 0;">Enter durations in ms, optional fade=NN</p>

      <div class="row" style="gap:0.5rem; flex-wrap:wrap;">
        <button data-cmd="sos" style="background:#2b0d0d; border-color:#a33; color:#ffdede;">SOS</button>
        <button data-cmd="sos stop">SOS Stop</button>
        <span class="status-chip" style="color:var(--muted);">SOS: 100% brightness + pattern</span>
      </div>
    </div>

    <div class="card"  style="flex:1;">
      <h3>Wake / Sleep</h3>
      <p class="hint" style="margin-top:0;">Wake timer uses seconds; sleep timer uses minutes; optional wake brightness is a percent override.</p>
      <div class="row" style="gap:0.6rem; align-items:center; flex-wrap:wrap;">
        <div class="input-group" style="max-width:180px;">
          <label class="sr-only" for="wakeSec">Wake duration seconds</label>
          <input id="wakeSec" type="number" min="5" max="600" step="5" value="180" />
          <span class="input-suffix">s</span>
          <button id="btnWake">Wake</button>
        </div>
        <label class="pill" style="cursor:pointer; margin:0;">
          <input type="checkbox" id="wakeSoft" style="margin-right:0.35rem;" />Soft
        </label>
        <select id="wakeMode" style="min-width:170px;">
          <option value="">Mode unver√§ndert</option>
        </select>
        <div class="input-group" style="width:150px;">
          <label class="sr-only" for="wakeBri">Wake brightness percent</label>
          <input id="wakeBri" type="number" min="1" max="100" step="1" placeholder="Bri %" />
          <span class="input-suffix">%</span>
          <button id="wakeBriClr" title="Bri Feld leeren">X</button>
        </div>
        <button id="btnWakeStop">Wake stop</button>
      </div>
      <div class="row" style="gap:0.6rem; align-items:center; flex-wrap:wrap; margin-top:0.4rem;">
        <div class="input-group" style="max-width:180px;">
          <label class="sr-only" for="sleepMin">Sleep minutes</label>
          <input id="sleepMin" type="number" min="1" max="240" step="1" value="15" />
          <span class="input-suffix">min</span>
          <button id="btnSleep">Sleep</button>
        </div>
        <button id="btnSleepStop">Sleep stop</button>
      </div>
    </div>

    <div class="card"  style="flex:1;">
      <h3>Custom</h3>
      <p class="hint" style="margin-top:0;">Custom step sets milliseconds between pattern points; CSV values stay normalized (0..1).</p>
      <div class="row">
        <div class="input-group">
          <label class="sr-only" for="customStep">Custom pattern step</label>
          <input id="customStep" type="number" min="100" max="5000" step="50" value="800" />
          <span class="input-suffix">ms</span>
          <button id="btnCustomStep">Set Step</button>
        </div>
      </div>
      <h4 style="margin-bottom:0.3rem;">Pattern Editor</h4>
      <div id="customEditor"></div>
      <div class="row" style="gap:0.5rem;">
        <button id="btnCustomAdd">Add Point</button>
        <button id="btnCustomClear">Clear</button>
        <button id="btnCustomSend">Send Custom</button>
      </div>
      <label>CSV values (0..1)</label>
      <textarea id="customCsv" rows="4" style="width:100%;"></textarea>
    </div>

    <div class="card"  style="flex:1;">
      <h3>Settings</h3>
      <div class="row" style="align-items:flex-start; flex-direction: column; flex-wrap: wrap;">
        <label style="min-width:120px;">Quick tap modes:</label>
        <div id="quickList" class="row" style="flex:1; gap:0.05rem;"></div>
        <div class="row" style="gap:0.4rem; align-items:center; margin-top:0.3rem; flex-wrap:wrap;">
          <button id="btnQuickAll">All</button>
          <button id="btnQuickNone">None</button>
          <button id="btnQuickDefault">Default</button>
          <button id="btnQuickApply" title="Applies selection for fast switch tap cycling">Apply</button>
        </div>
      </div>
      <div class="row">
        <label>IdleOff (min, 0=off)</label>
        <div class="input-group">
          <label class="sr-only" for="idleMin">Idle off minutes</label>
          <input id="idleMin" type="number" min="0" max="180" step="1" value="0" />
          <span class="input-suffix">min</span>
          <button id="btnIdle">Set</button>
        </div>
      </div>
      <div class="row" style="align-items:flex-start;">
        <div class="input-group" style="flex:1;">
          <textarea id="importArea" rows="2" style="flex:1; min-width:180px;" placeholder="paste cfg export here"></textarea>
          <button id="btnImport">Import cfg</button>
        </div>
      </div>
      <div class="row">
        <button id="btnFactory" style="background:#2b0d0d; border-color:#a33; color:#fdd;">Factory Reset</button>
      </div>
    </div>
    <div class="card"  style="flex:1;">
      <h3>Profiles</h3>
      <div class="row" style="gap:0.5rem; align-items:center; flex-wrap:wrap;">
        <label>Slot</label>
        <select id="profileSlot">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
        </select>
        <button id="btnProfileSave">Save</button>
        <button id="btnProfileLoad">Load</button>
        <button id="btnProfileExport">Export</button>
        <button id="btnProfileImport">Import</button>
      </div>
      <label>Profile blob (cfg import ...)</label>
      <textarea id="profileBlob" rows="3" style="width:100%;" placeholder="cfg import bri=..."></textarea>
      <p style="color:var(--muted); margin:0.35rem 0 0;">Export loads the slot, then captures cfg export; Import applies blob and saves to slot.</p>
      <div class="row" style="gap:0.4rem; align-items:center;">
        <button id="btnProfileQR">Show QR</button>
        <img id="profileQRImg" alt="Profile QR" style="width:140px; height:140px; border:1px solid var(--border); border-radius:8px; display:none;" />
      </div>
    </div>
    <div class="card"  style="flex:1;">
      <h3 style="display:flex; align-items:center; gap:0.6rem; justify-content:space-between;">
        <span>Presence</span>
        <label class="pill" style="cursor:pointer; margin:0;">
          <input type="checkbox" id="presenceToggle" style="margin-right:0.35rem;" />Presence
        </label>
      </h3>
      <div class="row" style="gap:0.6rem; align-items:center;">
        <span id="presenceStatus" style="color:var(--muted);">Last seen: n/a</span>
        <select id="presenceKnown" style="min-width:170px;">
          <option value="">recent devices</option>
        </select>
        <button id="btnPresenceUse">Use</button>
        <button id="btnPresenceRefresh">Refresh</button>
      </div>
      <div class="row">
        <div class="input-group">
          <label class="sr-only" for="presenceMac">Presence MAC address</label>
          <input id="presenceMac" type="text" placeholder="AA:BB:CC:DD:EE:FF" size="20" />
          <button id="btnPresenceSet">Set</button>
          <button id="btnPresenceClear" data-cmd="presence clear" style="border-radius:0 6px 6px 0;">Clear</button>
        </div>
      </div>
    </div>

    <div class="card"  style="flex:1;">
      <h3 style="display:flex; align-items:center; gap:0.6rem; justify-content:space-between;">
        <span>Touch</span>
        <label class="pill" style="cursor:pointer; margin:0;">
          <input type="checkbox" id="touchDimToggle" style="margin-right:0.35rem;" />TouchDim
        </label>
      </h3>
      <p class="hint" style="margin-top:0;">Hold time is milliseconds; thresholds are raw counts from the touch sensor.</p>
      <div class="row">
        <span class="status-chip" id="touchDetail">base -- | raw -- | delta -- | thr --/--</span>
      </div>
      <div class="row">
        <label>Touch hold (ms)</label>
        <div class="input-group">
          <label class="sr-only" for="touchHold">Touch hold milliseconds</label>
          <input id="touchHold" type="number" min="500" max="5000" step="100" value="1000" />
          <span class="input-suffix">ms</span>
          <button id="btnTouchHold">Set</button>
        </div>
      </div>
      <div class="row">
        <label>Touch On</label>
        <div class="input-group" style="max-width:170px;">
          <label class="sr-only" for="touchOn">Touch on threshold</label>
          <input id="touchOn" type="number" min="1" max="200" step="1" value="10" />
          <span class="input-suffix">cnt</span>
          <button id="btnTouchTune">Set</button>
        </div>
        <label>Touch Off</label>
        <div class="input-group" style="max-width:170px;">
          <label class="sr-only" for="touchOff">Touch off threshold</label>
          <input id="touchOff" type="number" min="1" max="200" step="1" value="6" />
          <span class="input-suffix">cnt</span>
          <button id="btnTouchTuneOff">Set</button>
        </div>
      </div>
      <div class="row">
        <button id="btnCalibTouch">calibrate touch</button>
        <button id="btnCalib">calibrate baseline</button>
      </div>
    </div>


    <div class="card"  id="lightCard" style="display:none; flex: 1;">
      <h3>Light Sensor</h3>
      <p class="hint" style="margin-top:0;">Gain and clamp values are normalized multipliers; tune to limit how light input affects brightness.</p>
      <div class="row" style="align-items:center; gap:0.5rem;">
        <label class="pill" style="cursor:pointer; margin:0;">
          <input type="checkbox" id="lightToggle" style="margin-right:0.35rem;" />Light Auto
        </label>
        <span class="status-chip">Light: <span id="lightState">--</span></span>
        <button id="btnLightCalib">Calibrate</button>
      </div>
      <div class="slider-group">
        <div class="slider-top">
          <span>Gain</span>
          <label class="sr-only" for="lightGainNum">Light gain value</label>
          <div style="display:flex; align-items:center; gap:0.3rem;">
            <input id="lightGainNum" class="slider-number" type="number" min="0.1" max="5" step="0.1" value="1.0" />
            <span class="input-suffix">x</span>
          </div>
        </div>
        <div class="slider-row">
          <label class="sr-only" for="lightGain">Light gain slider</label>
          <input id="lightGain" type="range" min="0.1" max="5" step="0.1" value="1.0" />
        </div>
      </div>
      <div class="slider-group">
        <div class="slider-top">
          <span>Clamp Min</span>
          <label class="sr-only" for="lightClampMinNum">Light clamp min value</label>
          <div style="display:flex; align-items:center; gap:0.3rem;">
            <input id="lightClampMinNum" class="slider-number" type="number" min="0" max="1.2" step="0.01" value="0.20" />
            <span class="input-suffix">x</span>
          </div>
        </div>
        <div class="slider-row">
          <label class="sr-only" for="lightClampMin">Light clamp min slider</label>
          <input id="lightClampMin" type="range" min="0" max="1.2" step="0.01" value="0.20" />
        </div>
      </div>
      <div class="slider-group">
        <div class="slider-top">
          <span>Clamp Max</span>
          <label class="sr-only" for="lightClampMaxNum">Light clamp max value</label>
          <div style="display:flex; align-items:center; gap:0.3rem;">
            <input id="lightClampMaxNum" class="slider-number" type="number" min="0" max="1.5" step="0.01" value="1.00" />
            <span class="input-suffix">x</span>
          </div>
        </div>
        <div class="slider-row">
          <label class="sr-only" for="lightClampMax">Light clamp max slider</label>
          <input id="lightClampMax" type="range" min="0" max="1.5" step="0.01" value="1.00" />
        </div>
      </div>
    </div>

    <div class="card"  id="musicCard" style="display:none; flex: 1;">
      <h3>Music Mode</h3>
      <p class="hint" style="margin-top:0;">Clap threshold and sensitivity are multipliers; cooldown is milliseconds between clap triggers.</p>
      <div class="row" style="align-items:center; gap:0.5rem;">
        <label class="pill" style="cursor:pointer; margin:0;">
          <input type="checkbox" id="musicToggle" style="margin-right:0.35rem;" />Music
        </label>
        <span class="status-chip">Music: <span id="musicState">--</span></span>
      </div>
      <div class="row" style="align-items:center; gap:0.5rem; flex-wrap:wrap;">
        <label class="pill" style="cursor:pointer; margin:0;">
          <input type="checkbox" id="clapToggle" style="margin-right:0.35rem;" />Clap
        </label>
        <div class="slider-group" style="flex:1; min-width:200px; margin:0;">
          <div class="slider-top">
            <span>Clap Thr</span>
            <label class="sr-only" for="clapThrNum">Clap threshold value</label>
            <div style="display:flex; align-items:center; gap:0.3rem;">
              <input id="clapThrNum" class="slider-number" type="number" min="0.05" max="1.5" step="0.01" value="0.35" />
              <span class="input-suffix">x</span>
            </div>
          </div>
          <div class="slider-row">
            <label class="sr-only" for="clapThr">Clap threshold slider</label>
            <input id="clapThr" type="range" min="0.05" max="1.5" step="0.01" value="0.35" />
          </div>
        </div>
        <div class="input-group" style="max-width:160px;">
          <label class="sr-only" for="clapCool">Clap cooldown milliseconds</label>
          <input id="clapCool" type="number" min="200" max="5000" step="50" value="800" />
          <span class="input-suffix">ms</span>
          <button id="btnClapCool">Set</button>
        </div>
      </div>
      <div class="slider-group">
        <div class="slider-top">
          <span>Sensitivity</span>
          <label class="sr-only" for="musicGainNum">Music sensitivity value</label>
          <div style="display:flex; align-items:center; gap:0.3rem;">
            <input id="musicGainNum" class="slider-number" type="number" min="0.1" max="5" step="0.1" value="1.0" />
            <span class="input-suffix">x</span>
          </div>
        </div>
        <div class="slider-row">
          <label class="sr-only" for="musicGain">Music sensitivity slider</label>
          <input id="musicGain" type="range" min="0.1" max="5" step="0.1" value="1.0" />
        </div>
      </div>
      <p style="color:var(--muted); margin:0.2rem 0 0;">Toggles audio-reactive pattern (if built).</p>
    </div>

  </div>
  </div>

  <div class="row" style="align-items:center; justify-content:space-between;">
    <h3 style="margin:0;">Log</h3>
    <div class="row" style="gap:0.4rem;">
      <label class="pill" style="cursor:pointer; margin:0;">
        <input type="checkbox" id="liveLogToggle" style="margin-right:0.35rem;" checked />Live log
      </label>
      <button id="btnStatus">Status</button>
      <button id="btnCfgExport">cfg export</button>
    </div>
  </div>
  <div class="log-block">
    <pre id="log"></pre>
    <div class="row log-row" style="margin:0;">
      <label class="sr-only" for="cmdInput">Command input</label>
      <input id="cmdInput" type="text" placeholder="type command" style="flex:1; min-width:200px;" />
      <button id="btnSend">Send</button>
    </div>
  </div>

  <div class="grid" style="margin-top:1rem;">
    <div class="card">
      <h3>BLE GUIDs</h3>
      <table class="info-table">
        <thead><tr><th>Label</th><th>Value</th><th>Copy</th></tr></thead>
        <tbody id="guidTable"></tbody>
      </table>
    </div>
    <div class="card">
      <h3>Command Reference & Links</h3>
      <table class="info-table">
        <thead><tr><th>Command</th><th>Description</th></tr></thead>
        <tbody>
          <tr><td>on / off / toggle</td><td>Switch lamp power</td></tr>
          <tr><td>mode N / next / prev</td><td>Select pattern</td></tr>
          <tr><td>auto on|off</td><td>Auto-cycle patterns</td></tr>
          <tr><td>bri X</td><td>Brightness 0..100%</td></tr>
          <tr><td>notify d1 d2 ... [fade=ms]</td><td>Blink pattern (ms)</td></tr>
          <tr><td>quick 1,2,...</td><td>Set fast-switch cycle list</td></tr>
          <tr><td>pat scale 0.1-5</td><td>Pattern speed factor</td></tr>
          <tr><td>touchdim on|off</td><td>Enable touch dimming</td></tr>
          <tr><td>touch tune on off</td><td>Set touch thresholds</td></tr>
          <tr><td>ramp MS / idle MIN</td><td>Ramp and auto-off</td></tr>
          <tr><td>profile save/load</td><td>Store/recall profiles (no touch/presence/quick)</td></tr>
          <tr><td>presence on|off|set|clear</td><td>Presence control</td></tr>
          <tr><td>sos [stop]</td><td>100% brightness + SOS pattern; stop restores</td></tr>
          <tr><td>wake [s] / sleep [m]</td><td>Start fades</td></tr>
          <tr><td>custom ...</td><td>Custom pattern CSV</td></tr>
          <tr><td>cfg export / import</td><td>Backup/restore settings</td></tr>
          <tr><td>status / help</td><td>Show status or commands</td></tr>
        </tbody>
      </table>
      <div class="row" style="margin-top:0.6rem;">
        <a class="pill" href="https://play.google.com/store/apps/details?id=net.dinglisch.android.taskerm" target="_blank" rel="noopener">Tasker (Play Store)</a>
        <a class="pill" href="https://github.com/Haschtl/Tasker-Ble-Writer/actions" target="_blank" rel="noopener">Tasker-BLE-Writer Actions</a>
    <a class="pill" href="https://github.com/Haschtl/Steinlampe/actions/workflows/ci.yml" target="_blank" rel="noopener">Firmware Build (Actions)</a>
      </div>
    </div>
  </div>

  <script>
    const SERVICE = 'd94d86d7-1eaf-47a4-9d1e-7a90bf34e66b';
    const CMD_CHAR = '4bb5047d-0d8b-4c5e-81cd-6fb5c0d1d1f7';
    const STATUS_CHAR = 'c5ad78b6-9b77-4a96-9a42-8e6e9a40c123';
    const PATTERN_LABELS = [
      'Konstant', 'Atmung', 'Atmung Warm', 'Atmung 2', 'Sinus',
      'Zig-Zag', 'Saegezahn', 'Pulsierend', 'Heartbeat', 'Heartbeat Alarm', 'Comet', 'Aurora', 'Polizei DE', 'Camera', 'TV Static', 'Funkeln',
      'Kerze Soft', 'Kerze', 'Lagerfeuer', 'Stufen', 'Zwinkern', 'Gluehwuermchen',
      'Popcorn', 'Weihnacht', 'Saber Idle', 'Saber Clash', 'Emergency Bridge', 'Arc Reactor',
      'Warp Core', 'KITT Scanner', 'Tron Grid', 'Gewitter', 'Distant Storm', 'Rolling Thunder', 'Heat Lightning',
      'Strobe Front', 'Sheet Lightning', 'Mixed Storm', 'Sonnenuntergang', 'Alert', 'SOS', 'Custom', 'Musik'
    ];
    const PROFILE_SLOTS = 3;

    let cmdChar = null;
    let statusChar = null;
    let device = null;
    let reconnecting = false;
    let serialPort = null;
    let serialWriter = null;
    let serialReader = null;
    let lastCmdText = '';
    let lastCmdTime = 0;
    let lastPresenceTs = 0;
    const presenceHistory = new Set();
    let pendingProfileExport = null;
    let pendingProfileQR = false;
    let lastCfgExport = '';
    let patternCount = PATTERN_LABELS.length;
    let lastDeviceType = localStorage.getItem('lastDeviceType') || '';
    let lastDeviceName = localStorage.getItem('lastDeviceName') || '';
    let lastDeviceId = localStorage.getItem('lastDeviceId') || '';

    const logEl = document.getElementById('log');
    let liveLogEnabled = true;
    let lastLogLine = '';
    let lastLogMs = 0;
    function log(msg) {
      if (!liveLogEnabled) return;
      const now = Date.now();
      if (msg === lastLogLine && (now - lastLogMs) < 400) {
        return; // dedupe bursts
      }
      lastLogLine = msg;
      lastLogMs = now;
      const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      logEl.textContent += line;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function persistLastDevice(type, dev) {
      if (!dev) return;
      lastDeviceType = type;
      lastDeviceName = dev.name || '';
      lastDeviceId = dev.id || '';
      localStorage.setItem('lastDeviceType', lastDeviceType);
      localStorage.setItem('lastDeviceName', lastDeviceName);
      localStorage.setItem('lastDeviceId', lastDeviceId);
    }

    async function connect(existingDevice = null) {
      if (!navigator.bluetooth) {
        log('Web Bluetooth not supported or not available (needs Chrome/Edge over HTTPS/localhost; enable chrome://flags/#enable-experimental-web-platform-features on some platforms).');
        return;
      }
      try {
        if (existingDevice) {
          device = existingDevice;
        } else {
          let reqOpts = { filters: [{ services: [SERVICE] }], optionalServices: [SERVICE] };
          try {
            device = await navigator.bluetooth.requestDevice(reqOpts);
          } catch (e1) {
            log('Filter request failed, trying acceptAllDevices...');
            device = await navigator.bluetooth.requestDevice({ acceptAllDevices: true, optionalServices: [SERVICE] });
          }
        }

        log('Connecting...');
        const server = await device.gatt.connect();
        device.addEventListener('gattserverdisconnected', async () => {
          log('Disconnected');
          document.getElementById('status').textContent = 'Disconnected';
          if (document.getElementById('autoReconnect').checked && device) {
            reconnecting = true;
            try {
              log('Reconnecting...');
              await device.gatt.connect();
              log('Reconnected');
              document.getElementById('status').textContent = 'Connected to ' + device.name;
            } catch (e) {
              log('Reconnect failed: ' + e);
            } finally {
              reconnecting = false;
            }
          }
        });
        log('Discover service');
        const service = await server.getPrimaryService(SERVICE);

        // List available characteristics for debugging
        try {
          const chars = await service.getCharacteristics();
          log('Found chars: ' + chars.map(c => c.uuid).join(', '));
        } catch (e) {
          log('Could not list characteristics: ' + e);
        }

        log('Discover cmd/status chars');
        try {
          cmdChar = await service.getCharacteristic(CMD_CHAR);
        } catch (e) {
          log('Cmd char not found: ' + e);
          throw e;
        }
        try {
          statusChar = await service.getCharacteristic(STATUS_CHAR);
        } catch (e) {
          log('Status char not found: ' + e);
          throw e;
        }

        let notified = false;
        // Attach notifications on cmdChar (firmware sends feedback here)
        if (cmdChar && cmdChar.properties && cmdChar.properties.notify) {
          try {
            await cmdChar.startNotifications();
            cmdChar.addEventListener('characteristicvaluechanged', onNotify);
            log('Cmd notify enabled');
          } catch (e) {
            log('Cmd notify not available: ' + e);
          }
        }

        // Attach notifications on statusChar (UI updates only, no log to avoid duplicates)
        if (statusChar && statusChar.properties && statusChar.properties.notify) {
          try {
            await statusChar.startNotifications();
            statusChar.addEventListener('characteristicvaluechanged', (ev) => {
              const txt = new TextDecoder().decode(ev.target.value || new DataView());
              txt.split(/\r?\n/).forEach(line => updateUIFromStatus(line.trim()));
            });
            log('Status notify enabled');
            notified = true;
          } catch (e) {
            log('Status notify not available; using read fallback');
          }
        } else {
          log('Status notify not supported by firmware');
        }

        if (statusChar && !notified) {
          try {
            const val = await statusChar.readValue();
            const txt = new TextDecoder().decode(val || new DataView());
            txt.split(/\r?\n/).forEach(line => updateUIFromStatus(line.trim()));
          } catch (e2) {
            log('Status read failed: ' + e2);
          }
        }
        document.getElementById('status').textContent = 'Connected to ' + device.name;
        log('Connected to ' + device.name);
        persistLastDevice('ble', device);
        sendCmd('status');
        setTimeout(() => sendCmd('status'), 300);
      } catch (e) {
        log('Connect error: ' + e);
      }
    }

    async function connectSerial(portOverride = null) {
      if (!('serial' in navigator)) {
        log('Web Serial not supported (needs Chrome/Edge over HTTPS/localhost)');
        return;
      }
      try {
        serialPort = portOverride || await navigator.serial.requestPort();
        await serialPort.open({ baudRate: 115200 });
        const encoder = new TextEncoderStream();
        serialWriter = encoder.writable.getWriter();
        encoder.readable.pipeTo(serialPort.writable);

        const reader = serialPort.readable.getReader();
        const decoder = new TextDecoder();
        serialReader = reader;
        let buffer = '';
        log('Serial connected');
        document.getElementById('status').textContent = 'Serial connected';
        persistLastDevice('serial', { name: 'Serial', id: 'serial' });
        (async () => {
          try {
            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              buffer += decoder.decode(value, { stream: true });
              let idx;
              while ((idx = buffer.indexOf('\n')) >= 0) {
                const line = buffer.slice(0, idx).trim();
                buffer = buffer.slice(idx + 1);
                if (line) {
                  log(line);
                  onNotify({ target: { value: new TextEncoder().encode(line) } });
                }
              }
            }
          } catch (e) {
            log('Serial read error: ' + e);
          } finally {
            reader.releaseLock();
            serialReader = null;
            serialWriter = null;
            if (serialPort) await serialPort.close();
            serialPort = null;
            document.getElementById('status').textContent = 'Disconnected';
          }
        })();
      } catch (e) {
        log('Serial connect error: ' + e);
      }
    }

    function onNotify(e) {
      const txt = new TextDecoder().decode(e.target.value || new DataView());
      txt.split(/\r?\n/).forEach(line => {
        if (line.trim()) log(line.trim());
        updateUIFromStatus(line.trim());
      });
    }

    function updateUIFromStatus(line) {
      if (!line) return;
      const lastStatusEl = document.getElementById('lastStatus');
      if (lastStatusEl) lastStatusEl.textContent = 'Last status: ' + new Date().toLocaleTimeString();
      // Lamp state + brightness
    if (line.includes('Lamp=')) {
      const m = line.match(/Brightness=([0-9.]+)/);
      if (m) {
        const val = Math.round(parseFloat(m[1]));
        const bri = document.getElementById('bri');
        const briNum = document.getElementById('briNum');
        const briVal = document.getElementById('briVal');
        if (!Number.isNaN(val)) {
          bri.value = val;
          briVal.textContent = val;
          if (briNum) briNum.value = val;
        }
      }
      const lampState = line.match(/Lamp=([A-Z]+)/);
      const switchState = line.match(/Switch=([A-Z]+)/);
      const statusEl = document.getElementById('status');
      if (lampState && statusEl) statusEl.textContent = `Lamp ${lampState[1]}`;
      const lampToggle = document.getElementById('lampToggle');
      if (lampToggle && lampState) lampToggle.checked = (lampState[1] === 'ON');
      const switchSpan = document.getElementById('switchState');
      if (switchSpan && switchState) switchSpan.textContent = switchState[1];
    }
      // AutoCycle toggle from pattern line
      if (line.startsWith('Pattern ')) {
        const autoChk = document.getElementById('autoToggle');
        if (autoChk) autoChk.checked = line.includes('AutoCycle=ON');
        const speedMatch = line.match(/Speed=([0-9.]+)/);
        if (speedMatch) {
          const v = parseFloat(speedMatch[1]);
          const inp = document.getElementById('patSpeed');
          const num = document.getElementById('patSpeedNum');
          if (!Number.isNaN(v)) {
            if (inp) inp.value = v;
            if (num) num.value = v.toFixed(1);
          }
        }
        const modeMatch = line.match(/Pattern\s+(\d+)\/(\d+)/);
        if (modeMatch) {
          const idx = parseInt(modeMatch[1], 10);
          const total = parseInt(modeMatch[2], 10);
          if (!Number.isNaN(total) && total > 0) {
            patternCount = total;
            populateModes();
            renderQuickModes(getQuickSelection());
          }
          const sel = document.getElementById('modeSelect');
          if (sel && !Number.isNaN(idx)) sel.value = String(idx);
          window.currentPatternIndex = idx;
          window.patternCount = patternCount;
        }
      }
      if (line.startsWith('[Quick]')) {
        const csv = line.replace('[Quick]', '').trim();
        if (csv) {
          const parts = csv.toLowerCase() === 'none' ? [] : csv.split(',').map(x => parseInt(x.trim(), 10)).filter(n => !Number.isNaN(n));
          setQuickSelection(parts);
        }
      }
      if (line.startsWith('[Light]')) {
        const chip = document.getElementById('lightState');
        if (chip) {
          if (line.includes('N/A')) {
            chip.textContent = 'N/A';
            chip.style.color = 'var(--muted)';
          } else {
            const raw = line.match(/raw=([0-9]+)/);
            chip.textContent = 'ON' + (raw ? ` (${raw[1]})` : '');
            chip.style.color = '#8cf59b';
          }
        }
        const lt = document.getElementById('lightToggle');
    if (lt) lt.checked = !line.includes('N/A') && (line.includes('en=1') || line.includes('Enabled') || line.includes('ON'));
    const lc = document.getElementById('lightCard');
    if (lc) lc.style.display = line.includes('N/A') ? 'none' : 'block';
    // Hide duplicated status chip if card is visible
    if (lc && lc.style.display !== 'none' && chip && chip.closest('.status-chip')) {
      chip.closest('.status-chip').style.display = 'none';
    }
        const lmin = document.getElementById('lightClampMin');
        const lmax = document.getElementById('lightClampMax');
        const lminNum = document.getElementById('lightClampMinNum');
        const lmaxNum = document.getElementById('lightClampMaxNum');
        if (lmin && lmin.value === '') lmin.value = '0.20';
        if (lmax && lmax.value === '') lmax.value = '1.00';
        if (lminNum && lminNum.value === '') lminNum.value = '0.20';
        if (lmaxNum && lmaxNum.value === '') lmaxNum.value = '1.00';
      }
      if (line.startsWith('[Music]')) {
        const chip = document.getElementById('musicState');
        if (chip) {
          if (line.includes('N/A')) {
            chip.textContent = 'N/A';
            chip.style.color = 'var(--muted)';
          } else {
            chip.textContent = line.includes('ON') ? 'ON' : 'OFF';
            chip.style.color = line.includes('ON') ? '#8cf59b' : 'var(--muted)';
          }
        }
        const mt = document.getElementById('musicToggle');
        if (mt) mt.checked = line.includes('ON');
        const mc = document.getElementById('musicCard');
        if (mc) mc.style.display = line.includes('N/A') ? 'none' : 'block';
        if (mc && mc.style.display !== 'none' && chip && chip.closest('.status-chip')) {
          chip.closest('.status-chip').style.display = 'none';
        }
      }
      if (line.startsWith('[Clap]')) {
        const ct = document.getElementById('clapToggle');
        const thr = document.getElementById('clapThr');
        const thrNum = document.getElementById('clapThrNum');
        const cool = document.getElementById('clapCool');
        if (ct) ct.checked = line.includes('ON');
        const mThr = line.match(/thr=([0-9.]+)/);
        if (mThr) {
          const v = parseFloat(mThr[1]);
          if (!Number.isNaN(v)) {
            if (thr) thr.value = v.toFixed(2);
            if (thrNum) thrNum.value = v.toFixed(2);
          }
        }
        const mCool = line.match(/cool=([0-9]+)/);
        if (mCool && cool) cool.value = mCool[1];
      }
      // Presence address hint
      if (line.startsWith('Presence=')) {
        const addrMatch = line.match(/\(([^)]+)\)/);
        const input = document.getElementById('presenceMac');
        if (addrMatch && addrMatch[1] && input && !input.value) {
          input.value = addrMatch[1];
        }
        const pT = document.getElementById('presenceToggle');
        if (pT) pT.checked = line.includes('Presence=ON');
        const pStatus = document.getElementById('presenceStatus');
        const known = document.getElementById('presenceKnown');
        if (pStatus) {
          lastPresenceTs = Date.now();
          pStatus.textContent = 'Last seen: just now';
        }
        if (addrMatch && addrMatch[1] && known) {
          presenceHistory.add(addrMatch[1]);
          known.innerHTML = '<option value=\"\">recent devices</option>' + Array.from(presenceHistory).map(a => `<option value="${a}">${a}</option>`).join('');
        }
      }
      if (line.startsWith('[Touch]')) {
        const baseMatch = line.match(/base=([-0-9]+)/);
        const rawMatch = line.match(/raw=([-0-9]+)/);
        const deltaMatch = line.match(/delta=([-0-9]+)/);
        const thrOn = line.match(/thrOn=([-0-9]+)/);
        const thrOff = line.match(/thrOff=([-0-9]+)/);
        const active = line.includes('active=1');
        const touchState = document.getElementById('touchState');
        if (touchState) {
          touchState.textContent = active ? 'TOUCH' : 'idle';
          touchState.style.color = active ? '#8cf59b' : 'var(--muted)';
        }
        const touchDetail = document.getElementById('touchDetail');
        if (touchDetail) {
          touchDetail.textContent = `base ${baseMatch ? baseMatch[1] : '--'} | raw ${rawMatch ? rawMatch[1] : '--'} | delta ${deltaMatch ? deltaMatch[1] : '--'} | thr ${thrOn ? thrOn[1] : '--'}/${thrOff ? thrOff[1] : '--'}`;
        }
      }
      // cfg export capture (for profile export helper)
      if (line.startsWith('cfg import')) {
        lastCfgExport = line.trim();
        const blob = document.getElementById('profileBlob');
        if (pendingProfileExport && blob) {
          blob.value = lastCfgExport;
          log('Captured profile export: ' + lastCfgExport);
          pendingProfileExport = null;
          if (pendingProfileQR) {
            renderProfileQR();
            pendingProfileQR = false;
          }
        }
      }
      // Ramp/Idle/TouchDim
      if (line.startsWith('Ramp=')) {
        const r = line.match(/Ramp=([0-9]+)/);
        const rampMsEl = document.getElementById('rampMs');
        if (r && rampMsEl) rampMsEl.value = r[1];
        const i = line.match(/IdleOff=([0-9]+)m|IdleOff=off/);
        if (i) {
          const v = i[0].includes('off') ? 0 : parseInt(i[1]);
          const idleEl = document.getElementById('idleMin');
          if (idleEl) idleEl.value = v;
        }
        const td = document.getElementById('touchDimToggle');
        if (td) td.checked = line.includes('TouchDim=ON');
        const pf = document.getElementById('patFadeToggle');
        const pfVal = document.getElementById('patFadeVal');
        const pfAmt = document.getElementById('patFadeAmt');
        const pfNum = document.getElementById('patFadeNum');
        const m = line.match(/PatFade=([A-Z]+)\(([0-9.]+)/);
        if (pf) pf.checked = line.includes('PatFade=ON');
        if (m && pfVal && pfAmt) {
          const v = parseFloat(m[2]);
          if (!Number.isNaN(v)) {
            pfVal.textContent = v.toFixed(2);
            pfAmt.value = v;
            if (pfNum) pfNum.value = v.toFixed(2);
          }
        }
        const reOn = line.match(/RampOn=([a-zA-Z-]+)\(([0-9.]+)\)/);
        const reOff = line.match(/RampOff=([a-zA-Z-]+)\(([0-9.]+)\)/);
        const selOn = document.getElementById('rampEaseOn');
        const selOff = document.getElementById('rampEaseOff');
        const powOn = document.getElementById('rampPowOn');
        const powOff = document.getElementById('rampPowOff');
        if (reOn) {
          if (selOn) selOn.value = reOn[1].toLowerCase();
          if (powOn) powOn.value = parseFloat(reOn[2]).toFixed(2);
        }
        if (reOff) {
          if (selOff) selOff.value = reOff[1].toLowerCase();
          if (powOff) powOff.value = parseFloat(reOff[2]).toFixed(2);
        }
        const pwmMatch = line.match(/PWM=([0-9.]+)/);
        const pwm = pwmMatch ? parseFloat(pwmMatch[1]) : null;
        const pc = document.getElementById('pwmCurve');
        const pcNum = document.getElementById('pwmCurveNum');
        if (pwm !== null && !Number.isNaN(pwm)) {
          if (pc) pc.value = pwm.toFixed(2);
          if (pcNum) pcNum.value = pwm.toFixed(2);
        }
      }
    }

    function currentModeNames() {
      const names = PATTERN_LABELS.slice(0, patternCount);
      for (let i = 1; i <= PROFILE_SLOTS; i++) {
        names.push(`Profile ${i}`);
      }
      return names;
    }

    function populateModes() {
      const sel = document.getElementById('modeSelect');
      sel.innerHTML = '';
      const names = currentModeNames();
      names.forEach((name, idx) => {
        const opt = document.createElement('option');
        opt.value = (idx + 1).toString();
        opt.textContent = `${idx + 1} - ${name}`;
        sel.appendChild(opt);
      });
      const wakeSel = document.getElementById('wakeMode');
      if (wakeSel) {
        const current = wakeSel.value;
        wakeSel.innerHTML = '<option value=\"\">Mode unver√§ndert</option>';
        names.forEach((name, idx) => {
          const opt = document.createElement('option');
          opt.value = (idx + 1).toString();
          opt.textContent = `${idx + 1} - ${name}`;
          wakeSel.appendChild(opt);
        });
        if (current && Array.from(wakeSel.options).some(o => o.value === current)) {
          wakeSel.value = current;
        }
      }
    }

  // --- Custom pattern editor ---
  let customPoints = [];

  function syncCustomCsvFromPoints() {
    const csv = customPoints.map(v => v.toFixed(3)).join(',');
    const area = document.getElementById('customCsv');
    if (area) area.value = csv;
  }

  function renderCustomEditor() {
    const wrap = document.getElementById('customEditor');
    if (!wrap) return;
    wrap.innerHTML = '';
    customPoints.forEach((v, idx) => {
      const row = document.createElement('div');
      row.className = 'bar-row';
      const range = document.createElement('input');
      range.type = 'range';
      range.min = '0';
      range.max = '1';
      range.step = '0.01';
      range.value = v.toFixed(2);
      const num = document.createElement('input');
      num.type = 'number';
      num.min = '0';
      num.max = '1';
      num.step = '0.01';
      num.value = v.toFixed(2);
      const del = document.createElement('button');
      del.textContent = 'X';
      del.onclick = () => {
        customPoints.splice(idx, 1);
        renderCustomEditor();
        syncCustomCsvFromPoints();
      };
      const syncVal = (nv) => {
        let val = parseFloat(nv);
        if (Number.isNaN(val)) val = 0;
        if (val < 0) val = 0;
        if (val > 1) val = 1;
        customPoints[idx] = val;
        range.value = val;
        num.value = val.toFixed(2);
        syncCustomCsvFromPoints();
      };
      range.oninput = (e) => syncVal(e.target.value);
      num.oninput = (e) => syncVal(e.target.value);
      row.appendChild(range);
      row.appendChild(num);
      row.appendChild(del);
      wrap.appendChild(row);
    });
  }

  function loadPointsFromCsv() {
    const area = document.getElementById('customCsv');
    if (!area) return;
    const csv = area.value.trim();
    if (!csv) {
      customPoints = [];
      renderCustomEditor();
      return;
    }
    const vals = csv.split(',').map(s => parseFloat(s));
    customPoints = vals.filter(v => !Number.isNaN(v)).map(v => {
      if (v < 0) return 0;
      if (v > 1) return 1;
      return v;
    });
    renderCustomEditor();
  }

    function populateGuids() {
      const rows = [
        { label: 'Service UUID', value: SERVICE },
        { label: 'Command Char', value: CMD_CHAR },
        { label: 'Status Char', value: STATUS_CHAR },
      ];
      const body = document.getElementById('guidTable');
      body.innerHTML = '';
      rows.forEach(r => {
        const tr = document.createElement('tr');
        const td1 = document.createElement('td'); td1.textContent = r.label;
        const td2 = document.createElement('td'); td2.textContent = r.value;
        const td3 = document.createElement('td');
        const btn = document.createElement('button');
        btn.className = 'copy-btn';
        btn.textContent = 'Copy';
        btn.dataset.copy = r.value;
        td3.appendChild(btn);
        tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
        body.appendChild(tr);
      });
    }

    function defaultQuickIndices() {
      const out = [];
      currentModeNames().forEach((name, idx) => {
        if (idx < 3) out.push(idx + 1);
        if (name.toLowerCase().includes('musik'))
          out.push(idx + 1);
      });
      return Array.from(new Set(out));
    }

    function renderQuickModes(selected = defaultQuickIndices()) {
      const wrap = document.getElementById('quickList');
      wrap.innerHTML = '';
      currentModeNames().forEach((name, idx) => {
        const lbl = document.createElement('label');
        lbl.className = 'quick-label';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.className = 'quickCb';
        cb.value = (idx + 1).toString();
        if (selected.includes(idx + 1)) cb.checked = true;
        lbl.appendChild(cb);
        const txt = document.createElement('span');
        txt.textContent = `${idx + 1}. ${name}`;
        lbl.appendChild(txt);
        wrap.appendChild(lbl);
      });
    }

    function getQuickSelection() {
      return Array.from(document.querySelectorAll('.quickCb'))
        .filter(cb => cb.checked)
        .map(cb => parseInt(cb.value, 10))
        .filter(n => !Number.isNaN(n));
    }

    function setQuickSelection(indices, useDefaultWhenEmpty = false) {
      const idxSet = (!indices || indices.length === 0) ? new Set(useDefaultWhenEmpty ? defaultQuickIndices() : []) : new Set(indices);
      document.querySelectorAll('.quickCb').forEach(cb => {
        cb.checked = idxSet.has(parseInt(cb.value, 10));
      });
    }

  async function sendCmd(text) {
      lastCmdText = text;
      lastCmdTime = Date.now();
    if (serialWriter) {
      try {
        await serialWriter.write(text + "\n");
        log('> ' + text + ' (serial)');
        return;
        } catch (e) {
          log('Serial send error: ' + e);
        }
      }

      if (!cmdChar) {
        log('Not connected');
        return;
      }
      try {
        const payload = new TextEncoder().encode(text + '\n');
        await cmdChar.writeValueWithoutResponse(payload);
        log('> ' + text);
      } catch (e) {
        log('Send error: ' + e);
      }
    }

    const btnConnect = document.getElementById('btnConnect');
    if (btnConnect) btnConnect.onclick = () => connect();
    document.querySelectorAll('button[data-cmd]').forEach(btn => {
      btn.onclick = () => {
        sendCmd(btn.dataset.cmd);
        if (btn.dataset.cmd === 'next' || btn.dataset.cmd === 'prev') {
          if (window.currentPatternIndex && window.patternCount) {
            let idx = window.currentPatternIndex;
            if (btn.dataset.cmd === 'next') idx = (idx % window.patternCount) + 1;
            else idx = (idx - 2 + window.patternCount) % window.patternCount + 1;
            const sel = document.getElementById('modeSelect');
            if (sel) sel.value = String(idx);
            window.currentPatternIndex = idx;
          }
        }
      };
    });
    const btnSerial = document.getElementById('btnSerial');
    if (btnSerial) btnSerial.onclick = () => connectSerial();
    const btnSend = document.getElementById('btnSend');
    if (btnSend) {
      btnSend.onclick = () => {
        const cmdIn = document.getElementById('cmdInput');
        const txt = cmdIn ? cmdIn.value.trim() : '';
        if (txt) sendCmd(txt);
      };
    }
    const briRange = document.getElementById('bri');
    const briNum = document.getElementById('briNum');
    const briVal = document.getElementById('briVal');
    const btnStatus = document.getElementById('btnStatus');
    if (btnStatus) {
      btnStatus.onclick = () => {
        const now = Date.now();
        if (lastCmdText === 'off' && now - lastCmdTime < 300) {
          setTimeout(() => sendCmd('status'), 250);
        } else {
          sendCmd('status');
        }
      };
    }
    const syncBri = (v, send = false) => {
      if (briRange) briRange.value = v;
      if (briNum) briNum.value = v;
      if (briVal) briVal.textContent = v;
      if (send) sendCmd('bri ' + v);
    };
    if (briRange) {
      briRange.oninput = e => syncBri(e.target.value);
      briRange.onchange = e => syncBri(e.target.value, true);
    }
    if (briNum) {
      briNum.oninput = e => syncBri(e.target.value);
      briNum.onchange = e => syncBri(e.target.value, true);
    }

    const btnPresenceSet = document.getElementById('btnPresenceSet');
    if (btnPresenceSet) {
      btnPresenceSet.onclick = () => {
        const macEl = document.getElementById('presenceMac');
        const mac = macEl ? macEl.value.trim() : '';
        if (mac) sendCmd('presence set ' + mac);
      };
    }
    const btnPresenceUse = document.getElementById('btnPresenceUse');
    if (btnPresenceUse) {
      btnPresenceUse.onclick = () => {
        const sel = document.getElementById('presenceKnown');
        if (sel && sel.value) {
          document.getElementById('presenceMac').value = sel.value;
          sendCmd('presence set ' + sel.value);
        }
      };
    }
    const btnPresenceRefresh = document.getElementById('btnPresenceRefresh');
    if (btnPresenceRefresh) btnPresenceRefresh.onclick = () => sendCmd('status');
    // auto status every 10s
    setInterval(() => {
      if (cmdChar || serialWriter) sendCmd('status');
    }, 10000);
    const btnStatusInline = document.getElementById('btnStatus');
    if (btnStatusInline) btnStatusInline.onclick = () => sendCmd('status');
    const btnCfgExport = document.getElementById('btnCfgExport');
    if (btnCfgExport) btnCfgExport.onclick = () => sendCmd('cfg export');
    const liveLogToggle = document.getElementById('liveLogToggle');
    if (liveLogToggle) liveLogToggle.onchange = (e) => { liveLogEnabled = e.target.checked; };
    document.getElementById('modeSelect').onchange = (e) => {
      const val = e.target.value;
      if (val) {
        if (val.startsWith('profile-')) {
          const slot = val.split('-')[1];
          sendCmd('profile load ' + slot);
        } else {
          sendCmd('mode ' + val);
        }
      }
    };
    document.getElementById('autoToggle').onchange = (e) => {
      sendCmd(e.target.checked ? 'auto on' : 'auto off');
    };
    const patSpeedEl = document.getElementById('patSpeed');
    const patSpeedNum = document.getElementById('patSpeedNum');
    const syncPatSpeed = (v, send = false) => {
      if (patSpeedEl) patSpeedEl.value = v;
      if (patSpeedNum) patSpeedNum.value = v;
      if (send) sendCmd('pat scale ' + v);
    };
    if (patSpeedEl) {
      patSpeedEl.oninput = (e) => syncPatSpeed(e.target.value);
      patSpeedEl.onchange = (e) => syncPatSpeed(e.target.value, true);
    }
    if (patSpeedNum) {
      patSpeedNum.oninput = (e) => syncPatSpeed(e.target.value);
      patSpeedNum.onchange = (e) => syncPatSpeed(e.target.value, true);
    }
    const easeSample = (t, type, pow) => {
      t = Math.max(0, Math.min(1, t));
      switch (type) {
        case 'linear': return t;
        case 'ease-in': return Math.pow(t, pow);
        case 'ease-out': return 1 - Math.pow(1 - t, pow);
        case 'ease-in-out': {
          const p = pow;
          return t < 0.5 ? 0.5 * Math.pow(t * 2, p) : 1 - 0.5 * Math.pow((1 - t) * 2, p);
        }
        case 'ease':
        default: return t * t * (3 - 2 * t);
      }
    };
    const drawRampPreview = (svgId, typeSel, powInput) => {
      const svg = document.getElementById(svgId);
      const type = typeSel ? typeSel.value : 'ease';
      const pow = powInput ? parseFloat(powInput.value || '2') : 2;
      if (!svg) return;
      const w = 100, h = 50;
      let path = '';
      for (let i = 0; i <= 20; i++) {
        const t = i / 20;
        const y = easeSample(t, type, pow);
        const px = (t * w).toFixed(2);
        const py = (h - y * h).toFixed(2);
        path += (i === 0 ? 'M' : 'L') + px + ' ' + py + ' ';
      }
      svg.innerHTML = `<path d="${path}" stroke="#5be6ff" stroke-width="2" fill="none"/>`;
    };

    populateModes();
    renderQuickModes();
    populateGuids();
    loadPointsFromCsv();
    const tdToggle = document.getElementById('touchDimToggle');
    if (tdToggle) {
      tdToggle.onchange = (e) => sendCmd(e.target.checked ? 'touchdim on' : 'touchdim off');
    }
    const lampToggle = document.getElementById('lampToggle');
    if (lampToggle) {
      const lampHandler = (e) => sendCmd(e.target.checked ? 'on' : 'off');
      lampToggle.oninput = lampHandler;
      lampToggle.onclick = lampHandler;
    }
    const presToggle = document.getElementById('presenceToggle');
    if (presToggle) {
      presToggle.onchange = (e) => sendCmd(e.target.checked ? 'presence on' : 'presence off');
    }
    const pfToggle = document.getElementById('patFadeToggle');
    const pfAmt = document.getElementById('patFadeAmt');
    const pfVal = document.getElementById('patFadeVal');
    const pfNum = document.getElementById('patFadeNum');
    if (pfToggle) {
      pfToggle.onchange = (e) => sendCmd(e.target.checked ? 'pat fade on' : 'pat fade off');
    }
    const syncPf = (v, send = false) => {
      if (pfVal) pfVal.textContent = Number(v).toFixed(2);
      if (pfAmt) pfAmt.value = v;
      if (pfNum) pfNum.value = v;
      if (send) sendCmd('pat fade amt ' + v);
    };
    if (pfAmt) {
      pfAmt.oninput = (e) => syncPf(e.target.value);
      pfAmt.onchange = (e) => syncPf(e.target.value, true);
      syncPf(pfAmt.value);
    }
    if (pfNum) {
      pfNum.oninput = (e) => syncPf(e.target.value);
      pfNum.onchange = (e) => syncPf(e.target.value, true);
    }
    const rampEaseOn = document.getElementById('rampEaseOn');
    const rampEaseOff = document.getElementById('rampEaseOff');
    const rampPowOn = document.getElementById('rampPowOn');
    const rampPowOff = document.getElementById('rampPowOff');
    const rampPowOnRange = document.getElementById('rampPowOnRange');
    const rampPowOffRange = document.getElementById('rampPowOffRange');
    if (rampEaseOn) rampEaseOn.onchange = () => { drawRampPreview('rampPrevOn', rampEaseOn, rampPowOn); sendCmd(`ramp ease on ${rampEaseOn.value} ${rampPowOn ? rampPowOn.value : ''}`); };
    if (rampPowOn) rampPowOn.onchange = () => { drawRampPreview('rampPrevOn', rampEaseOn, rampPowOn); sendCmd(`ramp ease on ${rampEaseOn ? rampEaseOn.value : 'ease'} ${rampPowOn.value}`); };
    if (rampEaseOff) rampEaseOff.onchange = () => { drawRampPreview('rampPrevOff', rampEaseOff, rampPowOff); sendCmd(`ramp ease off ${rampEaseOff.value} ${rampPowOff ? rampPowOff.value : ''}`); };
    if (rampPowOff) rampPowOff.onchange = () => { drawRampPreview('rampPrevOff', rampEaseOff, rampPowOff); sendCmd(`ramp ease off ${rampEaseOff ? rampEaseOff.value : 'ease'} ${rampPowOff.value}`); };
    if (rampPowOnRange) {
      rampPowOnRange.oninput = (e) => { if (rampPowOn) rampPowOn.value = parseFloat(e.target.value).toFixed(2); drawRampPreview('rampPrevOn', rampEaseOn, rampPowOn); };
      rampPowOnRange.onchange = (e) => { if (rampPowOn) rampPowOn.value = parseFloat(e.target.value).toFixed(2); sendCmd(`ramp ease on ${rampEaseOn ? rampEaseOn.value : 'ease'} ${rampPowOn ? rampPowOn.value : ''}`); };
    }
    if (rampPowOffRange) {
      rampPowOffRange.oninput = (e) => { if (rampPowOff) rampPowOff.value = parseFloat(e.target.value).toFixed(2); drawRampPreview('rampPrevOff', rampEaseOff, rampPowOff); };
      rampPowOffRange.onchange = (e) => { if (rampPowOff) rampPowOff.value = parseFloat(e.target.value).toFixed(2); sendCmd(`ramp ease off ${rampEaseOff ? rampEaseOff.value : 'ease'} ${rampPowOff ? rampPowOff.value : ''}`); };
    }
    drawRampPreview('rampPrevOn', rampEaseOn, rampPowOn);
    drawRampPreview('rampPrevOff', rampEaseOff, rampPowOff);
    const pwmCurve = document.getElementById('pwmCurve');
    const pwmCurveNum = document.getElementById('pwmCurveNum');
    const syncPwm = (v, send = false) => {
      if (pwmCurve) pwmCurve.value = v;
      if (pwmCurveNum) pwmCurveNum.value = v;
      if (send) sendCmd('pwm curve ' + v);
    };
    if (pwmCurve) {
      pwmCurve.oninput = (e) => syncPwm(e.target.value);
      pwmCurve.onchange = (e) => syncPwm(e.target.value, true);
    }
    if (pwmCurveNum) {
      pwmCurveNum.oninput = (e) => syncPwm(e.target.value);
      pwmCurveNum.onchange = (e) => syncPwm(e.target.value, true);
    }
    document.getElementById('btnQuickApply').onclick = () => {
      const sel = getQuickSelection();
      sendCmd(sel.length ? ('quick ' + sel.join(',')) : 'quick default');
    };
    const btnQuickAll = document.getElementById('btnQuickAll');
    const btnQuickNone = document.getElementById('btnQuickNone');
    const btnQuickDefault = document.getElementById('btnQuickDefault');
    if (btnQuickAll) btnQuickAll.onclick = () => setQuickSelection(MODE_NAMES.map((_, i) => i + 1));
    if (btnQuickNone) btnQuickNone.onclick = () => setQuickSelection([]);
    if (btnQuickDefault) btnQuickDefault.onclick = () => setQuickSelection(defaultQuickIndices());
    const getProfileSlot = () => {
      const inlineSel = document.getElementById('profileSlotInline');
      const baseSel = document.getElementById('profileSlot');
      const v = (inlineSel && inlineSel.value) ? inlineSel.value : (baseSel ? baseSel.value : '1');
      return parseInt(v, 10) || 1;
    };
    const btnProfileSave = document.getElementById('btnProfileSave');
    const btnProfileLoad = document.getElementById('btnProfileLoad');
    const btnProfileExport = document.getElementById('btnProfileExport');
    const btnProfileImport = document.getElementById('btnProfileImport');
    const btnProfileSaveInline = document.getElementById('btnProfileSaveInline');
    const btnProfileLoadInline = document.getElementById('btnProfileLoadInline');
    const profileSlotInline = document.getElementById('profileSlotInline');
    const profileSlotBase = document.getElementById('profileSlot');
    if (profileSlotInline && profileSlotBase) {
      profileSlotInline.onchange = () => { profileSlotBase.value = profileSlotInline.value; };
      profileSlotBase.onchange = () => { profileSlotInline.value = profileSlotBase.value; };
    }
    if (btnProfileSave) btnProfileSave.onclick = () => sendCmd('profile save ' + getProfileSlot());
    if (btnProfileLoad) btnProfileLoad.onclick = () => sendCmd('profile load ' + getProfileSlot());
    if (btnProfileSaveInline) btnProfileSaveInline.onclick = () => sendCmd('profile save ' + getProfileSlot());
    if (btnProfileLoadInline) btnProfileLoadInline.onclick = () => sendCmd('profile load ' + getProfileSlot());
    if (btnProfileExport) btnProfileExport.onclick = () => {
      pendingProfileExport = getProfileSlot();
      sendCmd('profile load ' + pendingProfileExport);
      setTimeout(() => sendCmd('cfg export'), 200);
    };
    if (btnProfileImport) btnProfileImport.onclick = () => {
      const blob = (document.getElementById('profileBlob') || {}).value || '';
      const slot = getProfileSlot();
      if (!blob.trim()) return;
      const text = blob.trim().startsWith('cfg import') ? blob.trim() : ('cfg import ' + blob.trim());
      sendCmd(text);
      setTimeout(() => sendCmd('profile save ' + slot), 250);
    };
    const btnProfileQuick1 = document.getElementById('btnProfileQuick1');
    const btnProfileQuick2 = document.getElementById('btnProfileQuick2');
    const btnProfileQuick3 = document.getElementById('btnProfileQuick3');
    if (btnProfileQuick1) btnProfileQuick1.onclick = () => sendCmd('profile load 1');
    if (btnProfileQuick2) btnProfileQuick2.onclick = () => sendCmd('profile load 2');
    if (btnProfileQuick3) btnProfileQuick3.onclick = () => sendCmd('profile load 3');
    const btnTouchHold = document.getElementById('btnTouchHold');
    if (btnTouchHold) {
      btnTouchHold.onclick = () => {
        const v = document.getElementById('touchHold') ? document.getElementById('touchHold').value : '';
        if (v) sendCmd('touch hold ' + v);
      };
    }
    const btnRamp = document.getElementById('btnRamp');
    if (btnRamp) {
      btnRamp.onclick = () => {
        const rampMs = document.getElementById('rampMs');
        if (!rampMs) return;
        const v = rampMs.value;
        const range = document.getElementById('rampMsRange');
        if (range) range.value = v;
        const lbl = document.getElementById('rampMsLabel');
        if (lbl) lbl.textContent = v;
        sendCmd('ramp ' + v);
      };
    }
    const rampMsRange = document.getElementById('rampMsRange');
    if (rampMsRange) {
      rampMsRange.oninput = (e) => {
        const v = e.target.value;
        const rampMs = document.getElementById('rampMs');
        if (rampMs) rampMs.value = v;
        const lbl = document.getElementById('rampMsLabel');
        if (lbl) lbl.textContent = v;
      };
      rampMsRange.onchange = (e) => {
        const v = e.target.value;
        const rampMs = document.getElementById('rampMs');
        if (rampMs) rampMs.value = v;
        const lbl = document.getElementById('rampMsLabel');
        if (lbl) lbl.textContent = v;
        sendCmd('ramp ' + v);
      };
    }
    document.getElementById('btnIdle').onclick = () => {
      const v = document.getElementById('idleMin').value;
      sendCmd('idle ' + v);
    };
    document.getElementById('btnCustomStep').onclick = () => {
      const v = document.getElementById('customStep').value;
      sendCmd('custom step ' + v);
    };
    const notifyDropdown = document.getElementById('notifyDropdown');
    const notifyToggle = document.getElementById('notifyOptsToggle');
    if (notifyToggle && notifyDropdown) {
      notifyToggle.setAttribute('aria-haspopup', 'true');
      notifyToggle.setAttribute('aria-expanded', 'false');
      notifyToggle.onclick = (e) => {
        e.stopPropagation();
        const isOpen = notifyDropdown.classList.toggle('open');
        notifyToggle.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
      };
      document.addEventListener('click', (e) => {
        if (!notifyDropdown.contains(e.target)) {
          notifyDropdown.classList.remove('open');
          notifyToggle.setAttribute('aria-expanded', 'false');
        }
      });
    }
    const btnNotify = document.getElementById('btnNotify');
    if (btnNotify) {
      btnNotify.onclick = () => {
        const seq = document.getElementById('notifySeq').value.trim();
        const fade = document.getElementById('notifyFade').value.trim();
        const repEl = document.getElementById('notifyRepeat');
        let rep = repEl ? parseInt(repEl.value || '1', 10) : 1;
        if (Number.isNaN(rep) || rep < 1) rep = 1;
        if (rep > 10) rep = 10;
        let cmd = 'notify';
        if (seq) {
          let built = seq;
          if (rep > 1) {
            const parts = seq.split(/\s+/).filter(Boolean);
            built = Array(rep).fill(parts.join(' ')).join(' ');
          }
          cmd += ' ' + built;
        }
        if (fade && parseInt(fade, 10) > 0) cmd += ' fade=' + fade;
        sendCmd(cmd);
      };
    }
    const btnNotifyStop = document.getElementById('btnNotifyStop');
    if (btnNotifyStop) {
      btnNotifyStop.onclick = () => sendCmd('notify stop');
    }
    document.querySelectorAll('.notifyPreset').forEach(btn => {
      btn.onclick = () => {
        if (btn.dataset.cmd) {
          sendCmd(btn.dataset.cmd);
          return;
        }
        const seq = btn.dataset.seq || '';
        const fade = btn.dataset.fade || '';
        const seqEl = document.getElementById('notifySeq');
        const fadeEl = document.getElementById('notifyFade');
        if (seqEl) seqEl.value = seq;
        if (fadeEl && fade.length) fadeEl.value = fade;
        log(`Preset: ${seq}${fade ? ' fade=' + fade : ''}`);
      };
    });
    const btnWake = document.getElementById('btnWake');
    if (btnWake) btnWake.onclick = () => {
      const v = document.getElementById('wakeSec').value || '180';
      let cmd = 'wake';
      const soft = document.getElementById('wakeSoft');
      const modeSel = document.getElementById('wakeMode');
      const bri = document.getElementById('wakeBri');
      if (soft && soft.checked) cmd += ' soft';
      if (modeSel && modeSel.value) cmd += ' mode=' + modeSel.value;
      if (bri && bri.value) cmd += ' bri=' + bri.value;
      cmd += ' ' + v;
      sendCmd(cmd.trim());
    };
    const wakeBriClr = document.getElementById('wakeBriClr');
    if (wakeBriClr) wakeBriClr.onclick = () => {
      const bri = document.getElementById('wakeBri');
      if (bri) bri.value = '';
    };
    const btnSleep = document.getElementById('btnSleep');
    if (btnSleep) btnSleep.onclick = () => {
      const v = document.getElementById('sleepMin').value || '15';
      sendCmd('sleep ' + v);
    };
    const btnWakeStop = document.getElementById('btnWakeStop');
    if (btnWakeStop) btnWakeStop.onclick = () => sendCmd('wake stop');
    const btnSleepStop = document.getElementById('btnSleepStop');
    if (btnSleepStop) btnSleepStop.onclick = () => sendCmd('sleep stop');
    const btnCustomSend = document.getElementById('btnCustomSend');
    if (btnCustomSend) {
      btnCustomSend.onclick = () => {
        syncCustomCsvFromPoints();
        const csv = document.getElementById('customCsv').value.trim();
        if (csv) sendCmd('custom ' + csv);
      };
    }
    const btnCustomAdd = document.getElementById('btnCustomAdd');
    if (btnCustomAdd) {
      btnCustomAdd.onclick = () => {
        customPoints.push(0.5);
        renderCustomEditor();
        syncCustomCsvFromPoints();
      };
    }
    const btnCustomClear = document.getElementById('btnCustomClear');
    if (btnCustomClear) {
      btnCustomClear.onclick = () => {
        customPoints = [];
        renderCustomEditor();
        syncCustomCsvFromPoints();
      };
    }
    const customCsvArea = document.getElementById('customCsv');
    if (customCsvArea) {
      customCsvArea.onchange = loadPointsFromCsv;
    }
    const btnFactory = document.getElementById('btnFactory');
    if (btnFactory) {
      btnFactory.onclick = () => {
        const ok = confirm('Factory reset all settings?');
        if (ok) sendCmd('factory');
      };
    }
    const lt = document.getElementById('lightToggle');
    const lg = document.getElementById('lightGain');
    const lgNum = document.getElementById('lightGainNum');
    if (lt) lt.onchange = (e) => sendCmd(e.target.checked ? 'light on' : 'light off');
    const syncLg = (v, send = false) => {
      if (lg) lg.value = v;
      if (lgNum) lgNum.value = v;
      if (send) sendCmd('light gain ' + v);
    };
    if (lg) {
      lg.oninput = (e) => syncLg(e.target.value);
      lg.onchange = (e) => syncLg(e.target.value, true);
    }
    if (lgNum) {
      lgNum.oninput = (e) => syncLg(e.target.value);
      lgNum.onchange = (e) => syncLg(e.target.value, true);
    }
    const btnLightCalib = document.getElementById('btnLightCalib');
    if (btnLightCalib) btnLightCalib.onclick = () => sendCmd('light calib');
    const mt = document.getElementById('musicToggle');
    if (mt) mt.onchange = (e) => sendCmd(e.target.checked ? 'music on' : 'music off');
    const ct = document.getElementById('clapToggle');
    if (ct) ct.onchange = (e) => sendCmd(e.target.checked ? 'clap on' : 'clap off');
    const clapThr = document.getElementById('clapThr');
    const clapThrNum = document.getElementById('clapThrNum');
    const syncClapThr = (v, send = false) => {
      if (clapThr) clapThr.value = v;
      if (clapThrNum) clapThrNum.value = v;
      if (send) sendCmd('clap thr ' + v);
    };
    if (clapThr) {
      clapThr.oninput = (e) => syncClapThr(e.target.value);
      clapThr.onchange = (e) => syncClapThr(e.target.value, true);
    }
    if (clapThrNum) {
      clapThrNum.oninput = (e) => syncClapThr(e.target.value);
      clapThrNum.onchange = (e) => syncClapThr(e.target.value, true);
    }
    const btnClapCool = document.getElementById('btnClapCool');
    if (btnClapCool) btnClapCool.onclick = () => {
      const v = document.getElementById('clapCool').value || '800';
      sendCmd('clap cool ' + v);
    };
    const lmin = document.getElementById('lightClampMin');
    const lmax = document.getElementById('lightClampMax');
    const lminNum = document.getElementById('lightClampMinNum');
    const lmaxNum = document.getElementById('lightClampMaxNum');
    const syncClamp = (fromMin, send = false) => {
      let mn = parseFloat(lmin ? lmin.value : (lminNum ? lminNum.value : '0.2')) || 0;
      let mx = parseFloat(lmax ? lmax.value : (lmaxNum ? lmaxNum.value : '1.0')) || 1;
      if (mn < 0) mn = 0;
      if (mx > 1.5) mx = 1.5;
      if (mn >= mx) mn = Math.max(0, Math.min(mx - 0.01, mn));
      if (lmin) lmin.value = mn;
      if (lmax) lmax.value = mx;
      if (lminNum) lminNum.value = mn;
      if (lmaxNum) lmaxNum.value = mx;
      if (send) sendCmd(`light clamp ${mn.toFixed(2)} ${mx.toFixed(2)}`);
    };
    if (lmin) { lmin.oninput = () => syncClamp(true); lmin.onchange = () => syncClamp(true, true); }
    if (lmax) { lmax.oninput = () => syncClamp(false); lmax.onchange = () => syncClamp(false, true); }
    if (lminNum) { lminNum.oninput = () => syncClamp(true); lminNum.onchange = () => syncClamp(true, true); }
    if (lmaxNum) { lmaxNum.oninput = () => syncClamp(false); lmaxNum.onchange = () => syncClamp(false, true); }
    const mg = document.getElementById('musicGain');
    const mgNum = document.getElementById('musicGainNum');
    const syncMusicGain = (v, send = false) => {
      if (mg) mg.value = v;
      if (mgNum) mgNum.value = v;
      if (send) sendCmd('music sens ' + v);
    };
    if (mg) { mg.oninput = (e) => syncMusicGain(e.target.value); mg.onchange = (e) => syncMusicGain(e.target.value, true); }
    if (mgNum) { mgNum.oninput = (e) => syncMusicGain(e.target.value); mgNum.onchange = (e) => syncMusicGain(e.target.value, true); }

    function renderProfileQR() {
      const blobEl = document.getElementById('profileBlob');
      const img = document.getElementById('profileQRImg');
      if (!img || !blobEl) return;
      const txt = blobEl.value.trim();
      if (!txt) { img.style.display = 'none'; return; }
      const data = encodeURIComponent(txt);
      const url = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${data}`;
      img.onload = () => { img.style.display = 'block'; };
      img.onerror = () => { img.style.display = 'none'; log('QR laden fehlgeschlagen'); };
      img.src = url;
      img.style.display = 'block';
    }

    const btnProfileQR = document.getElementById('btnProfileQR');
    if (btnProfileQR) {
      btnProfileQR.onclick = () => {
        const blobEl = document.getElementById('profileBlob');
        const blobTxt = blobEl ? blobEl.value.trim() : '';
        if (!blobTxt) {
          pendingProfileExport = getProfileSlot();
          pendingProfileQR = true;
          sendCmd('profile load ' + pendingProfileExport);
          setTimeout(() => sendCmd('cfg export'), 200);
          return;
        }
        renderProfileQR();
      };
    }
    // Auto-reconnect last device (serial if permission already granted; BLE if cached device is available)
    async function autoReconnectLast() {
      if (lastDeviceType === 'serial' && navigator.serial && navigator.serial.getPorts) {
        try {
          const ports = await navigator.serial.getPorts();
          if (ports && ports.length > 0) {
            log('Auto-opening last serial device...');
            connectSerial(ports[0]);
            return;
          }
        } catch (e) {
          log('Serial auto-open failed: ' + e);
        }
      }
      if (lastDeviceType === 'ble' && navigator.bluetooth && navigator.bluetooth.getDevices) {
        try {
          const devs = await navigator.bluetooth.getDevices();
          const match = devs.find(d => (d.id && lastDeviceId && d.id === lastDeviceId) || (d.name && lastDeviceName && d.name === lastDeviceName));
          if (match) {
            log('Auto-connecting to cached BLE device...');
            connect(match);
          }
        } catch (e) {
          log('BLE auto-connect not available: ' + e);
        }
      }
    }
    autoReconnectLast();
    const btnExport = document.getElementById('btnExport');
    if (btnExport) btnExport.onclick = () => sendCmd('cfg export');
    document.getElementById('btnImport').onclick = () => {
      const cfg = document.getElementById('importArea').value.trim();
      if (cfg) sendCmd(cfg.startsWith('cfg import') ? cfg : ('cfg import ' + cfg));
    };

    document.getElementById('btnTouchTune').onclick = () => {
      const on = document.getElementById('touchOn').value;
      const off = document.getElementById('touchOff').value;
      sendCmd(`touch tune ${on} ${off}`);
    };
    const btnTouchTuneOff = document.getElementById('btnTouchTuneOff');
    if (btnTouchTuneOff) {
      btnTouchTuneOff.onclick = () => {
        const on = document.getElementById('touchOn').value;
        const off = document.getElementById('touchOff').value;
        sendCmd(`touch tune ${on} ${off}`);
      };
    }
    document.getElementById('btnCalibTouch').onclick = () => sendCmd('calibrate touch');
    document.getElementById('btnCalib').onclick = () => sendCmd('calibrate');

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').then(() => {
          log('Service worker registered');
        }).catch((e) => log('SW register failed: ' + e));
      });
    }
    // Copy GUIDs
    document.body.addEventListener('click', (e) => {
      const target = e.target;
      if (target && target.dataset && target.dataset.copy) {
        const txt = target.dataset.copy;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(txt).then(() => log('Copied: ' + txt)).catch(() => log('Copy failed'));
        } else {
          log('Clipboard not available');
        }
      }
    });
  </script>
</body>
</html>
