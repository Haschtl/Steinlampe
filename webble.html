<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#0b0f1a" />
  <link rel="manifest" href="manifest.json" />
  <title>Quarzlampe Web BLE</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: #11182a;
      --border: #1f2b44;
      --accent: #5be6ff;
      --accent2: #8cf59b;
      --text: #eef2ff;
      --muted: #9fb2cc;
    }
    * { box-sizing: border-box; }
    body { font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif; margin: 0; background: radial-gradient(circle at 20% 20%, #111a2d, #0b0f1a 50%), #0b0f1a; color: var(--text); padding: 1.2rem; }
    h1 { margin: 0 0 0.6rem; letter-spacing: 0.02em; }
    h3 { margin-top: 0; color: var(--accent); }
    button, input, textarea { margin: 0.15rem; padding: 0.45rem 0.65rem; border-radius: 6px; border: 1px solid var(--border); background: #0f1525; color: var(--text); }
    button { cursor: pointer; transition: all 0.15s ease; }
    button:hover { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 0 1px #1a2438; }
    input, textarea { background: #0d1322; }
    select { background:#0f1525; color:var(--text); border:1px solid var(--border); border-radius:8px; padding:0.45rem 0.75rem; min-width:170px; appearance:none; -moz-appearance:none; -webkit-appearance:none; background-image: linear-gradient(45deg, transparent 50%, var(--accent) 50%), linear-gradient(135deg, var(--accent) 50%, transparent 50%); background-position: right 12px top 55%, right 6px top 55%; background-size: 10px 10px, 10px 10px; background-repeat: no-repeat; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1rem; }
    .card { border: 1px solid var(--border); padding: 0.85rem; border-radius: 10px; background: linear-gradient(145deg, rgba(255,255,255,0.02), rgba(0,0,0,0.2)); box-shadow: 0 5px 25px rgba(0,0,0,0.35); }
    #log { width: 100%; height: 220px; background:#0b0f1a; color: #8ce5ff; padding: 0.6rem; overflow-y: auto; font-family: 'SFMono-Regular', Menlo, monospace; border:1px solid var(--border); border-radius:8px; }
    .log-block { border:1px solid var(--border); border-radius:10px; overflow:hidden; background:#0b0f1a; box-shadow: 0 4px 20px rgba(0,0,0,0.25); }
    .log-block #log { border:none; border-bottom:1px solid var(--border); border-radius:0; margin:0; }
    .log-row { background:#0d1322; padding:0.5rem; }
    label { display:block; margin-top:0.35rem; font-size: 0.9rem; color: var(--muted); }
    .row { display:flex; flex-wrap:wrap; gap:0.4rem; align-items:center; }
    .pill { padding: 0.35rem 0.6rem; border-radius: 999px; background: #10172a; border:1px solid var(--border); color: var(--muted); font-size: 0.9rem; }
    .header { display:flex; gap:0.75rem; align-items:center; margin-bottom: 0.75rem; flex-wrap: wrap; }
    .header .pill, .header button { flex-shrink: 0; }
    #status { color: var(--accent2); }
    textarea { resize: vertical; }
    #quickList { display:grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap:0.45rem; align-items:start; width:100%; }
    .quick-label { display:flex; align-items:center; gap:0.35rem; padding:0.38rem 0.55rem; border:1px solid var(--border); border-radius:8px; background:#0d1322; color:var(--text); width:100%; }
    .quick-label input { accent-color: var(--accent); }
    table.info-table { width:100%; border-collapse: collapse; margin-top:0.5rem; }
    table.info-table th, table.info-table td { border:1px solid var(--border); padding:0.45rem 0.55rem; text-align:left; }
    table.info-table th { background:#10172a; color:var(--accent); }
    table.info-table tbody tr:nth-child(even) { background:#0d1322; }
    .copy-btn { padding:0.3rem 0.5rem; border-radius:6px; border:1px solid var(--border); background:#0f1525; color:var(--text); cursor:pointer; }
  </style>
</head>
<body>
  <div class="header">
    <h1>Quarzlampe Web BLE</h1>
    <button id="btnConnect">Connect</button>
    <button id="btnSerial">Connect Serial</button>
    <label class="pill" style="cursor:pointer;">
      <input type="checkbox" id="autoReconnect" style="margin-right:0.35rem;" checked />Auto-reconnect
    </label>
    <span class="pill" id="status">Not connected</span>
    <a class="pill" href="https://github.com/Haschtl/Steinlampe/actions/workflows/ci.yml" target="_blank" rel="noopener">Firmware Build (Actions)</a>
  </div>

  <div class="grid">
    <div class="card">
      <h3>Lamp</h3>
      <div class="row">
        <button data-cmd="on">On</button>
        <button data-cmd="off">Off</button>
        <button data-cmd="toggle">Toggle</button>
        <button data-cmd="sync" title="Align lamp state to physical switch">Sync</button>
      </div>
      <div class="row">
        <button data-cmd="prev">Prev</button>
        <select id="modeSelect" style="min-width:170px;"></select>
        <button data-cmd="next">Next</button>
      </div>
      <div class="row">
        <label class="pill" style="cursor:pointer;">
          <input type="checkbox" id="autoToggle" style="margin-right:0.35rem;" />AutoCycle
        </label>
      </div>
      <div class="row">
        <label>Pattern Speed: <span id="patSpeedVal">1.0</span>x</label>
        <input id="patSpeed" type="range" min="0.1" max="5" step="0.1" value="1.0" />
      </div>
      <label>Brightness: <span id="briVal">--</span>%</label>
      <input id="bri" type="range" min="1" max="100" value="70" />

      <div class="row" style="align-items:center;">
        <label class="pill" style="cursor:pointer;">
          <input type="checkbox" id="patFadeToggle" style="margin-right:0.35rem;" />Pattern Fade
        </label>
        <label style="min-width:120px;">Fade amount: <span id="patFadeVal">1.00</span>x</label>
        <input id="patFadeAmt" type="range" min="0.01" max="5" step="0.01" value="1.00" />
      </div>
    </div>

    <div class="card">
      <h3>Presence</h3>
      <div class="row">
        <input id="presenceMac" type="text" placeholder="AA:BB:CC:DD:EE:FF" size="20" />
        <button id="btnPresenceSet">Set</button>
        <button data-cmd="presence clear">Clear</button>
      </div>
      <div class="row">
        <button data-cmd="presence on">Presence On</button>
        <button data-cmd="presence off">Presence Off</button>
      </div>
    </div>

    <div class="card">
      <h3>Settings</h3>
      <div class="row" style="align-items:flex-start; flex-direction: column;">
        <label style="min-width:120px;">Quick tap modes:</label>
        <div id="quickList" class="row" style="flex:1; gap:0.05rem;"></div>
        <button id="btnQuickApply" title="Applies selection for fast switch tap cycling">Apply</button>
      </div>
      <div class="row">
        <label>Ramp (ms)</label>
        <input id="rampMs" type="number" min="50" max="5000" step="50" value="400" />
        <button id="btnRamp">Set</button>
      </div>
      <div class="row">
        <label>IdleOff (min, 0=off)</label>
        <input id="idleMin" type="number" min="0" max="180" step="1" value="0" />
        <button id="btnIdle">Set</button>
      </div>
      <div class="row" style="align-items:flex-start;">
        <textarea id="importArea" rows="2" style="flex:1; min-width:180px;" placeholder="paste cfg export here"></textarea>
        <button id="btnImport">Import cfg</button>
      </div>
    </div>

    <div class="card">
      <h3>Touch</h3>
      <div class="row">
        <label>Touch hold (ms)</label>
        <input id="touchHold" type="number" min="500" max="5000" step="100" value="1000" />
        <button id="btnTouchHold">Set</button>
      </div>
      <div class="row">
        <label>Touch On</label>
        <input id="touchOn" type="number" min="1" max="200" step="1" value="10" />
        <label>Touch Off</label>
        <input id="touchOff" type="number" min="1" max="200" step="1" value="6" />
        <button id="btnTouchTune">Set Tune</button>
      </div>
      <div class="row">
        <button id="btnCalibTouch">calibrate touch</button>
        <button id="btnCalib">calibrate baseline</button>
        <label class="pill" style="cursor:pointer;">
          <input type="checkbox" id="touchDimToggle" style="margin-right:0.35rem;" />TouchDim
        </label>
      </div>
    </div>

    <div class="card">
      <h3>Custom</h3>
      <div class="row">
        <input id="customStep" type="number" min="100" max="5000" step="50" value="800" />
        <button id="btnCustomStep">Set Step</button>
      </div>
      <label>CSV values (0..1)</label>
      <textarea id="customCsv" rows="4" style="width:100%;"></textarea>
      <button id="btnCustomSend">Send Custom</button>
    </div>

  </div>

  <div class="row" style="align-items:center; justify-content:space-between;">
    <h3 style="margin:0;">Log</h3>
    <div class="row" style="gap:0.4rem;">
      <button id="btnStatus">Status</button>
      <button id="btnCfgExport">cfg export</button>
    </div>
  </div>
  <div class="log-block">
    <pre id="log"></pre>
    <div class="row log-row" style="margin:0;">
      <input id="cmdInput" type="text" placeholder="type command" style="flex:1; min-width:200px;" />
      <button id="btnSend">Send</button>
    </div>
  </div>

  <div class="grid" style="margin-top:1rem;">
    <div class="card">
      <h3>BLE GUIDs</h3>
      <table class="info-table">
        <thead><tr><th>Label</th><th>Value</th><th>Copy</th></tr></thead>
        <tbody id="guidTable"></tbody>
      </table>
    </div>
    <div class="card">
      <h3>Command Reference & Links</h3>
      <table class="info-table">
        <thead><tr><th>Command</th><th>Description</th></tr></thead>
        <tbody>
          <tr><td>on / off / toggle</td><td>Switch lamp power</td></tr>
          <tr><td>mode N / next / prev</td><td>Select pattern</td></tr>
          <tr><td>auto on|off</td><td>Auto-cycle patterns</td></tr>
          <tr><td>bri X</td><td>Brightness 0..100%</td></tr>
          <tr><td>quick 1,2,...</td><td>Set fast-switch cycle list</td></tr>
          <tr><td>pat scale 0.1-5</td><td>Pattern speed factor</td></tr>
          <tr><td>touchdim on|off</td><td>Enable touch dimming</td></tr>
          <tr><td>touch tune on off</td><td>Set touch thresholds</td></tr>
          <tr><td>ramp MS / idle MIN</td><td>Ramp and auto-off</td></tr>
          <tr><td>presence on|off|set|clear</td><td>Presence control</td></tr>
          <tr><td>wake [s] / sleep [m]</td><td>Start fades</td></tr>
          <tr><td>custom ...</td><td>Custom pattern CSV</td></tr>
          <tr><td>cfg export / import</td><td>Backup/restore settings</td></tr>
          <tr><td>status / help</td><td>Show status or commands</td></tr>
        </tbody>
      </table>
      <div class="row" style="margin-top:0.6rem;">
        <a class="pill" href="https://play.google.com/store/apps/details?id=net.dinglisch.android.taskerm" target="_blank" rel="noopener">Tasker (Play Store)</a>
        <a class="pill" href="https://github.com/Haschtl/Tasker-Ble-Writer/actions" target="_blank" rel="noopener">Tasker-BLE-Writer Actions</a>
      </div>
    </div>
  </div>

  <script>
    const SERVICE = 'd94d86d7-1eaf-47a4-9d1e-7a90bf34e66b';
    const CMD_CHAR = '4bb5047d-0d8b-4c5e-81cd-6fb5c0d1d1f7';
    const STATUS_CHAR = 'c5ad78b6-9b77-4a96-9a42-8e6e9a40c123';
    const MODE_NAMES = [
      'Konstant', 'Atmung', 'Pulsierend', 'Funkeln', 'Kerze Soft',
      'Kerze', 'Lagerfeuer', 'Stufen', 'Zwinkern', 'Custom', 'Musik'
    ];

    let cmdChar = null;
    let statusChar = null;
    let device = null;
    let reconnecting = false;
    let serialPort = null;
    let serialWriter = null;
    let serialReader = null;

    const logEl = document.getElementById('log');
    function log(msg) {
      const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      logEl.textContent += line;
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function connect() {
      if (!navigator.bluetooth) {
        log('Web Bluetooth not supported or not available (needs Chrome/Edge over HTTPS/localhost; enable chrome://flags/#enable-experimental-web-platform-features on some platforms).');
        return;
      }
      try {
        let reqOpts = { filters: [{ services: [SERVICE] }], optionalServices: [SERVICE] };
        try {
          device = await navigator.bluetooth.requestDevice(reqOpts);
        } catch (e1) {
          log('Filter request failed, trying acceptAllDevices...');
          device = await navigator.bluetooth.requestDevice({ acceptAllDevices: true, optionalServices: [SERVICE] });
        }

        log('Connecting...');
        const server = await device.gatt.connect();
        device.addEventListener('gattserverdisconnected', async () => {
          log('Disconnected');
          document.getElementById('status').textContent = 'Disconnected';
          if (document.getElementById('autoReconnect').checked && device) {
            reconnecting = true;
            try {
              log('Reconnecting...');
              await device.gatt.connect();
              log('Reconnected');
              document.getElementById('status').textContent = 'Connected to ' + device.name;
            } catch (e) {
              log('Reconnect failed: ' + e);
            } finally {
              reconnecting = false;
            }
          }
        });
        log('Discover service');
        const service = await server.getPrimaryService(SERVICE);

        // List available characteristics for debugging
        try {
          const chars = await service.getCharacteristics();
          log('Found chars: ' + chars.map(c => c.uuid).join(', '));
        } catch (e) {
          log('Could not list characteristics: ' + e);
        }

        log('Discover cmd/status chars');
        try {
          cmdChar = await service.getCharacteristic(CMD_CHAR);
        } catch (e) {
          log('Cmd char not found: ' + e);
          throw e;
        }
        try {
          statusChar = await service.getCharacteristic(STATUS_CHAR);
        } catch (e) {
          log('Status char not found: ' + e);
          throw e;
        }

        let notified = false;
        // Attach notifications on cmdChar (firmware sends feedback here)
        if (cmdChar && cmdChar.properties && cmdChar.properties.notify) {
          try {
            await cmdChar.startNotifications();
            cmdChar.addEventListener('characteristicvaluechanged', onNotify);
            log('Cmd notify enabled');
          } catch (e) {
            log('Cmd notify not available: ' + e);
          }
        }

        // Attach notifications on statusChar
        if (statusChar && statusChar.properties && statusChar.properties.notify) {
          try {
            await statusChar.startNotifications();
            statusChar.addEventListener('characteristicvaluechanged', onNotify);
            log('Status notify enabled');
            notified = true;
          } catch (e) {
            log('Status notify not available; using read fallback');
          }
        } else {
          log('Status notify not supported by firmware');
        }

        if (statusChar && !notified) {
          try {
            const val = await statusChar.readValue();
            onNotify({ target: { value: val } });
          } catch (e2) {
            log('Status read failed: ' + e2);
          }
        }
        document.getElementById('status').textContent = 'Connected to ' + device.name;
        log('Connected to ' + device.name);
      } catch (e) {
        log('Connect error: ' + e);
      }
    }

    async function connectSerial() {
      if (!('serial' in navigator)) {
        log('Web Serial not supported (needs Chrome/Edge over HTTPS/localhost)');
        return;
      }
      try {
        serialPort = await navigator.serial.requestPort();
        await serialPort.open({ baudRate: 115200 });
        const encoder = new TextEncoderStream();
        serialWriter = encoder.writable.getWriter();
        encoder.readable.pipeTo(serialPort.writable);

        const reader = serialPort.readable.getReader();
        const decoder = new TextDecoder();
        serialReader = reader;
        let buffer = '';
        log('Serial connected');
        document.getElementById('status').textContent = 'Serial connected';
        (async () => {
          try {
            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              buffer += decoder.decode(value, { stream: true });
              let idx;
              while ((idx = buffer.indexOf('\n')) >= 0) {
                const line = buffer.slice(0, idx).trim();
                buffer = buffer.slice(idx + 1);
                if (line) {
                  log(line);
                  onNotify({ target: { value: new TextEncoder().encode(line) } });
                }
              }
            }
          } catch (e) {
            log('Serial read error: ' + e);
          } finally {
            reader.releaseLock();
            serialReader = null;
            serialWriter = null;
            if (serialPort) await serialPort.close();
            serialPort = null;
            document.getElementById('status').textContent = 'Disconnected';
          }
        })();
      } catch (e) {
        log('Serial connect error: ' + e);
      }
    }

    function onNotify(e) {
      const txt = new TextDecoder().decode(e.target.value || new DataView());
      txt.split(/\r?\n/).forEach(line => {
        if (line.trim()) log(line.trim());
        updateUIFromStatus(line.trim());
      });
    }

    function updateUIFromStatus(line) {
      if (!line) return;
      // Lamp state + brightness
      if (line.includes('Lamp=')) {
        const m = line.match(/Brightness=([0-9.]+)/);
        if (m) {
          const val = Math.round(parseFloat(m[1]));
          const bri = document.getElementById('bri');
          const briVal = document.getElementById('briVal');
          if (!Number.isNaN(val)) {
            bri.value = val;
            briVal.textContent = val;
          }
        }
        const lampState = line.match(/Lamp=([A-Z]+)/);
        const statusEl = document.getElementById('status');
        if (lampState && statusEl) statusEl.textContent = `Lamp ${lampState[1]}`;
      }
      // AutoCycle toggle from pattern line
      if (line.startsWith('Pattern ')) {
        const autoChk = document.getElementById('autoToggle');
        if (autoChk) autoChk.checked = line.includes('AutoCycle=ON');
        const speedMatch = line.match(/Speed=([0-9.]+)/);
        if (speedMatch) {
          const v = parseFloat(speedMatch[1]);
          const inp = document.getElementById('patSpeed');
          if (inp && !Number.isNaN(v)) {
            inp.value = v;
            const valEl = document.getElementById('patSpeedVal');
            if (valEl) valEl.textContent = v.toFixed(1);
          }
        }
      }
      if (line.startsWith('[Quick]')) {
        const csv = line.replace('[Quick]', '').trim();
        if (csv) {
          const parts = csv.toLowerCase() === 'none' ? [] : csv.split(',').map(x => parseInt(x.trim(), 10)).filter(n => !Number.isNaN(n));
          setQuickSelection(parts);
        }
      }
      // Presence address hint
      if (line.startsWith('Presence=')) {
        const addrMatch = line.match(/\(([^)]+)\)/);
        const input = document.getElementById('presenceMac');
        if (addrMatch && addrMatch[1] && input && !input.value) {
          input.value = addrMatch[1];
        }
      }
      // Ramp/Idle/TouchDim
      if (line.startsWith('Ramp=')) {
        const r = line.match(/Ramp=([0-9]+)/);
        if (r) document.getElementById('rampMs').value = r[1];
        const i = line.match(/IdleOff=([0-9]+)m|IdleOff=off/);
        if (i) {
          const v = i[0].includes('off') ? 0 : parseInt(i[1]);
          document.getElementById('idleMin').value = v;
        }
        const td = document.getElementById('touchDimToggle');
        if (td) td.checked = line.includes('TouchDim=ON');
        const pf = document.getElementById('patFadeToggle');
        const pfVal = document.getElementById('patFadeVal');
        const pfAmt = document.getElementById('patFadeAmt');
        const m = line.match(/PatFade=([A-Z]+)\(([0-9.]+)/);
        if (pf) pf.checked = line.includes('PatFade=ON');
        if (m && pfVal && pfAmt) {
          const v = parseFloat(m[2]);
          if (!Number.isNaN(v)) {
            pfVal.textContent = v.toFixed(2);
            pfAmt.value = v;
          }
        }
      }
    }

    function populateModes() {
      const sel = document.getElementById('modeSelect');
      sel.innerHTML = '';
      MODE_NAMES.forEach((name, idx) => {
        const opt = document.createElement('option');
        opt.value = (idx + 1).toString();
        opt.textContent = `${idx + 1} - ${name}`;
        sel.appendChild(opt);
      });
    }

    function populateGuids() {
      const rows = [
        { label: 'Service UUID', value: SERVICE },
        { label: 'Command Char', value: CMD_CHAR },
        { label: 'Status Char', value: STATUS_CHAR },
      ];
      const body = document.getElementById('guidTable');
      body.innerHTML = '';
      rows.forEach(r => {
        const tr = document.createElement('tr');
        const td1 = document.createElement('td'); td1.textContent = r.label;
        const td2 = document.createElement('td'); td2.textContent = r.value;
        const td3 = document.createElement('td');
        const btn = document.createElement('button');
        btn.className = 'copy-btn';
        btn.textContent = 'Copy';
        btn.dataset.copy = r.value;
        td3.appendChild(btn);
        tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
        body.appendChild(tr);
      });
    }

    function defaultQuickIndices() {
      const out = [];
      MODE_NAMES.forEach((name, idx) => {
        if (idx < 3) out.push(idx + 1);
        if (name.toLowerCase().includes('musik'))
          out.push(idx + 1);
      });
      return Array.from(new Set(out));
    }

    function renderQuickModes(selected = defaultQuickIndices()) {
      const wrap = document.getElementById('quickList');
      wrap.innerHTML = '';
      MODE_NAMES.forEach((name, idx) => {
        const lbl = document.createElement('label');
        lbl.className = 'quick-label';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.className = 'quickCb';
        cb.value = (idx + 1).toString();
        if (selected.includes(idx + 1)) cb.checked = true;
        lbl.appendChild(cb);
        const txt = document.createElement('span');
        txt.textContent = name;
        lbl.appendChild(txt);
        wrap.appendChild(lbl);
      });
    }

    function getQuickSelection() {
      return Array.from(document.querySelectorAll('.quickCb'))
        .filter(cb => cb.checked)
        .map(cb => parseInt(cb.value, 10))
        .filter(n => !Number.isNaN(n));
    }

    function setQuickSelection(indices) {
      const idxSet = new Set(indices);
      document.querySelectorAll('.quickCb').forEach(cb => {
        cb.checked = idxSet.size === 0 ? defaultQuickIndices().includes(parseInt(cb.value, 10)) : idxSet.has(parseInt(cb.value, 10));
      });
    }

    async function sendCmd(text) {
      if (serialWriter) {
        try {
          await serialWriter.write(text + "\n");
          log('> ' + text + ' (serial)');
          return;
        } catch (e) {
          log('Serial send error: ' + e);
        }
      }

      if (!cmdChar) {
        log('Not connected');
        return;
      }
      try {
        const payload = new TextEncoder().encode(text + '\n');
        await cmdChar.writeValueWithoutResponse(payload);
        log('> ' + text);
      } catch (e) {
        log('Send error: ' + e);
      }
    }

    document.getElementById('btnConnect').onclick = connect;
    document.querySelectorAll('button[data-cmd]').forEach(btn => {
      btn.onclick = () => sendCmd(btn.dataset.cmd);
    });
    document.getElementById('btnSerial').onclick = connectSerial;
    document.getElementById('btnSend').onclick = () => {
      const txt = document.getElementById('cmdInput').value.trim();
      if (txt) sendCmd(txt);
    };
    document.getElementById('bri').oninput = e => {
      document.getElementById('briVal').textContent = e.target.value;
    };
    document.getElementById('bri').onchange = e => sendCmd('bri ' + e.target.value);

    document.getElementById('btnPresenceSet').onclick = () => {
      const mac = document.getElementById('presenceMac').value.trim();
      if (mac) sendCmd('presence set ' + mac);
    };
    document.getElementById('btnStatus').onclick = () => sendCmd('status');
    document.getElementById('btnCfgExport').onclick = () => sendCmd('cfg export');
    document.getElementById('modeSelect').onchange = (e) => {
      const val = e.target.value;
      if (val) sendCmd('mode ' + val);
    };
    document.getElementById('autoToggle').onchange = (e) => {
      sendCmd(e.target.checked ? 'auto on' : 'auto off');
    };
    const patSpeedEl = document.getElementById('patSpeed');
    const patSpeedVal = document.getElementById('patSpeedVal');
    function updatePatSpeedLabel(v) {
      patSpeedVal.textContent = Number(v).toFixed(1);
    }
    patSpeedEl.oninput = (e) => updatePatSpeedLabel(e.target.value);
    patSpeedEl.onchange = (e) => sendCmd('pat scale ' + e.target.value);
    updatePatSpeedLabel(patSpeedEl.value);

    populateModes();
    renderQuickModes();
    populateGuids();
    const tdToggle = document.getElementById('touchDimToggle');
    if (tdToggle) {
      tdToggle.onchange = (e) => sendCmd(e.target.checked ? 'touchdim on' : 'touchdim off');
    }
    const pfToggle = document.getElementById('patFadeToggle');
    const pfAmt = document.getElementById('patFadeAmt');
    const pfVal = document.getElementById('patFadeVal');
    if (pfToggle) {
      pfToggle.onchange = (e) => sendCmd(e.target.checked ? 'pat fade on' : 'pat fade off');
    }
    const updatePfLabel = (v) => { if (pfVal) pfVal.textContent = Number(v).toFixed(2); };
    if (pfAmt) {
      pfAmt.oninput = (e) => updatePfLabel(e.target.value);
      pfAmt.onchange = (e) => sendCmd('pat fade amt ' + e.target.value);
      updatePfLabel(pfAmt.value);
    }
    document.getElementById('btnQuickApply').onclick = () => {
      const sel = getQuickSelection();
      sendCmd(sel.length ? ('quick ' + sel.join(',')) : 'quick default');
    };
    document.getElementById('btnTouchHold').onclick = () => {
      const v = document.getElementById('touchHold').value;
      sendCmd('touch hold ' + v);
    };
    document.getElementById('btnRamp').onclick = () => {
      const v = document.getElementById('rampMs').value;
      sendCmd('ramp ' + v);
    };
    document.getElementById('btnIdle').onclick = () => {
      const v = document.getElementById('idleMin').value;
      sendCmd('idle ' + v);
    };
    document.getElementById('btnCustomStep').onclick = () => {
      const v = document.getElementById('customStep').value;
      sendCmd('custom step ' + v);
    };
    document.getElementById('btnCustomSend').onclick = () => {
      const csv = document.getElementById('customCsv').value.trim();
      if (csv) sendCmd('custom ' + csv);
    };
    document.getElementById('btnExport').onclick = () => sendCmd('cfg export');
    document.getElementById('btnImport').onclick = () => {
      const cfg = document.getElementById('importArea').value.trim();
      if (cfg) sendCmd(cfg.startsWith('cfg import') ? cfg : ('cfg import ' + cfg));
    };

    document.getElementById('btnTouchTune').onclick = () => {
      const on = document.getElementById('touchOn').value;
      const off = document.getElementById('touchOff').value;
      sendCmd(`touch tune ${on} ${off}`);
    };
    document.getElementById('btnCalibTouch').onclick = () => sendCmd('calibrate touch');
    document.getElementById('btnCalib').onclick = () => sendCmd('calibrate');

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').then(() => {
          log('Service worker registered');
        }).catch((e) => log('SW register failed: ' + e));
      });
    }
    // Copy GUIDs
    document.body.addEventListener('click', (e) => {
      const target = e.target;
      if (target && target.dataset && target.dataset.copy) {
        const txt = target.dataset.copy;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(txt).then(() => log('Copied: ' + txt)).catch(() => log('Copy failed'));
        } else {
          log('Clipboard not available');
        }
      }
    });
  </script>
</body>
</html>
