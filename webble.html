<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#0b0f1a" />
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/svg+xml" href="icon-lamp.svg" />
  <title>Quarzlampe Web BLE</title>
  <style>
    :root {
      --bg: #0b0f1a;
      --panel: #11182a;
      --border: #1f2b44;
      --accent: #5be6ff;
      --accent2: #8cf59b;
      --text: #eef2ff;
      --muted: #9fb2cc;
    }
    * { box-sizing: border-box; }
    body { font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif; margin: 0; background: radial-gradient(circle at 20% 20%, #111a2d, #0b0f1a 50%), #0b0f1a; color: var(--text); padding: 1.2rem; }
    h1 { margin: 0 0 0.6rem; letter-spacing: 0.02em; }
    h3 { margin-top: 0; color: var(--accent); }
    button, input, textarea { margin: 0.15rem; padding: 0.45rem 0.65rem; border-radius: 6px; border: 1px solid var(--border); background: #0f1525; color: var(--text); }
    button { cursor: pointer; transition: all 0.15s ease; }
    button:hover { border-color: var(--accent); color: var(--accent); box-shadow: 0 0 0 1px #1a2438; }
    input, textarea { background: #0d1322; }
    select { background:#0f1525; color:var(--text); border:1px solid var(--border); border-radius:8px; padding:0.5rem 0.75rem; min-width:170px; appearance:none; -moz-appearance:none; -webkit-appearance:none; background-image: linear-gradient(45deg, transparent 50%, var(--accent) 50%), linear-gradient(135deg, var(--accent) 50%, transparent 50%); background-position: right 12px top 55%, right 6px top 55%; background-size: 10px 10px, 10px 10px; background-repeat: no-repeat; }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 1rem; }
    .card { border: 1px solid var(--border); padding: 0.85rem; border-radius: 10px; background: linear-gradient(145deg, rgba(255,255,255,0.02), rgba(0,0,0,0.2)); box-shadow: 0 5px 25px rgba(0,0,0,0.35); }
    #log { width: 100%; height: 220px; background:#0b0f1a; color: #8ce5ff; padding: 0.6rem; overflow-y: auto; font-family: 'SFMono-Regular', Menlo, monospace; border:1px solid var(--border); border-radius:8px; }
    .log-block { border:1px solid var(--border); border-radius:10px; overflow:hidden; background:#0b0f1a; box-shadow: 0 4px 20px rgba(0,0,0,0.25); }
    .log-block #log { border:none; border-bottom:1px solid var(--border); border-radius:0; margin:0; }
    .log-row { background:#0d1322; padding:0.5rem; }
    label { display:block; margin-top:0.35rem; font-size: 0.9rem; color: var(--muted); }
    .row { display:flex; flex-wrap:wrap; gap:0.4rem; align-items:center; }
    .pill { padding: 0.35rem 0.6rem; border-radius: 999px; background: #10172a; border:1px solid var(--border); color: var(--muted); font-size: 0.9rem; }
    .header { display:flex; gap:0.75rem; align-items:center; margin-bottom: 0.75rem; flex-wrap: wrap; }
    .header .pill, .header button { flex-shrink: 0; }
    #status { color: var(--accent2); }
    textarea { resize: vertical; }
    #quickList { display:grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap:0.45rem; align-items:start; width:100%; }
    .quick-label { display:flex; align-items:center; gap:0.35rem; padding:0.38rem 0.55rem; border:1px solid var(--border); border-radius:8px; background:#0d1322; color:var(--text); width:100%; }
    .quick-label input { accent-color: var(--accent); }
    table.info-table { width:100%; border-collapse: collapse; margin-top:0.5rem; }
    table.info-table th, table.info-table td { border:1px solid var(--border); padding:0.45rem 0.55rem; text-align:left; }
    table.info-table th { background:#10172a; color:var(--accent); }
    table.info-table tbody tr:nth-child(even) { background:#0d1322; }
    .copy-btn { padding:0.3rem 0.5rem; border-radius:6px; border:1px solid var(--border); background:#0f1525; color:var(--text); cursor:pointer; }
    .input-group { display:flex; align-items:stretch; gap:0; width:100%; }
    .input-group input,
    .input-group textarea { border-top-right-radius:0; border-bottom-right-radius:0; margin-right:0; flex:1; min-width:0; }
    .input-group button { border-top-left-radius:0; border-bottom-left-radius:0; margin-left:0; margin-right:0; }
    .slider-group { margin:0.35rem 0; }
    .slider-top { display:flex; justify-content:space-between; align-items:center; gap:0.6rem; color:var(--muted); }
    .slider-number { width:90px; text-align:right; }
    .slider-row { display:flex; gap:0.6rem; align-items:center; }
    .slider-row input[type=range] { flex:1; accent-color: var(--accent); height: 14px; border-radius: 999px; background: linear-gradient(90deg, rgba(91,230,255,0.4) 0%, rgba(88,129,255,0.2) 100%); }
    .slider-row input[type=range]::-webkit-slider-thumb { width:22px; height:22px; border-radius:50%; background: #0b0f1a; border:2px solid var(--accent); box-shadow: 0 6px 14px rgba(0,0,0,0.4); }
    .slider-row input[type=range]::-moz-range-thumb { width:22px; height:22px; border-radius:50%; background: #0b0f1a; border:2px solid var(--accent); box-shadow: 0 6px 14px rgba(0,0,0,0.4); }
    .bar-row { display:flex; align-items:center; gap:0.6rem; margin:0.25rem 0; }
    .bar-row input[type=range] { flex:1; accent-color: var(--accent2); }
    .bar-row input[type=number] { width:80px; text-align:right; }
    .bar-row button { padding:0.3rem 0.6rem; }
    .ramp-preview { width:140px; height:70px; border:1px solid var(--border); border-radius:8px; background:#0d1322; }
    .status-chip { padding:0.35rem 0.6rem; border-radius:999px; border:1px solid var(--border); background:#0d1322; color:var(--muted); }
  </style>
</head>
<body>
  <div class="header">
    <img src="icon-lamp.svg" alt="Lamp Icon" style="width:40px; height:40px; border-radius:8px; border:1px solid var(--border); background:#0b0f1a; padding:4px;" />
    <h1>Quarzlampe Web BLE</h1>
    <button id="btnConnect">Connect</button>
    <button id="btnSerial">Connect Serial</button>
    <label class="pill" style="cursor:pointer;">
      <input type="checkbox" id="autoReconnect" style="margin-right:0.35rem;" checked />Auto-reconnect
    </label>
    <span class="pill" id="status">Not connected</span>
    <span class="pill" id="lastStatus">Last status: --</span>
  </div>

  <div class="grid">
    <div class="card">
      <h3 style="display:flex; align-items:center; gap:0.6rem; justify-content:space-between;">
        <span>Lamp</span>
        <div class="row" style="gap:0.3rem; align-items:center; margin:0;">
          <label class="pill" style="cursor:pointer; margin:0;">
            <input type="checkbox" id="lampToggle" style="margin-right:0.35rem;" />On
          </label>
        </div>
      </h3>
      <div class="slider-group">
        <div class="slider-top">
          <span>Brightness</span>
          <div style="display:flex; gap:0.35rem; align-items:center;">
            <input id="briNum" class="slider-number" type="number" min="1" max="100" step="1" value="70" />
            <span id="briVal" style="display:none;">70</span>
          </div>
        </div>
        <div class="slider-row">
          <input id="bri" type="range" min="1" max="100" value="70" />
        </div>
      </div>
      <div class="row">
        <span class="status-chip">Switch: <span id="switchState">--</span></span>
        <span class="status-chip">Touch: <span id="touchState">--</span></span>
        <button data-cmd="sync" title="Align lamp state to physical switch">Sync</button>
      </div>
      <div class="input-group" style="max-width: 100%;">
        <button data-cmd="prev" style="border-radius:6px 0 0 6px;">Prev</button>
        <select id="modeSelect" style="min-width:170px; border-radius:0; margin:0; height:100%; margin-top: 0.125rem; padding-top:0.5rem; padding-bottom:0.35rem;"></select>
        <button data-cmd="next" style="border-radius:0 6px 6px 0;">Next</button>
      </div>
      <div class="row">
        <label class="pill" style="cursor:pointer;">
          <input type="checkbox" id="autoToggle" style="margin-right:0.35rem;" />AutoCycle
        </label>

        <label class="pill" style="cursor:pointer;">
          <input type="checkbox" id="patFadeToggle" style="margin-right:0.35rem;" />Pattern Fade
        </label>
      </div>
      <div class="slider-group">
        <div class="slider-top">
          <span>Speed</span>
          <input id="patSpeedNum" class="slider-number" type="number" min="0.1" max="5" step="0.1" value="1.0" />
        </div>
        <div class="slider-row">
          <input id="patSpeed" type="range" min="0.1" max="5" step="0.1" value="1.0" />
        </div>
      </div>

      <div class="slider-group">
        <div class="slider-top">
          <span>Fade</span>
          <input id="patFadeNum" class="slider-number" type="number" min="0.01" max="5" step="0.01" value="1.00" />
        </div>
        <div class="slider-row">
          <input id="patFadeAmt" type="range" min="0.01" max="5" step="0.01" value="1.00" />
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Ramps</h3>
      <div class="row">
        <label>Ramp (ms)</label>
        <div class="input-group">
          <input id="rampMs" type="number" min="50" max="5000" step="50" value="400" />
          <button id="btnRamp">Set</button>
        </div>
      </div>
      <div class="row" style="flex-wrap:wrap; gap:0.6rem;">
        <div>
          <label>Ramp On</label>
          <div class="row" style="gap:0.4rem; align-items:center;">
            <select id="rampEaseOn">
              <option value="linear">linear</option>
              <option value="ease">ease</option>
              <option value="ease-in">ease-in</option>
              <option value="ease-out">ease-out</option>
              <option value="ease-in-out">ease-in-out</option>
            </select>
            <input id="rampPowOn" type="number" min="0.01" max="10" step="0.01" value="2.0" style="width:90px;" />
          </div>
          <svg id="rampPrevOn" class="ramp-preview" viewBox="0 0 100 50"></svg>
        </div>
        <div>
          <label>Ramp Off</label>
          <div class="row" style="gap:0.4rem; align-items:center;">
            <select id="rampEaseOff">
              <option value="linear">linear</option>
              <option value="ease">ease</option>
              <option value="ease-in">ease-in</option>
              <option value="ease-out">ease-out</option>
              <option value="ease-in-out">ease-in-out</option>
            </select>
            <input id="rampPowOff" type="number" min="0.01" max="10" step="0.01" value="2.0" style="width:90px;" />
          </div>
          <svg id="rampPrevOff" class="ramp-preview" viewBox="0 0 100 50"></svg>
        </div>
      </div>
    </div>

    <div class="card">
      <h3>Notify</h3>
      <div class="row">
        <div class="input-group">
          <input id="notifySeq" type="text" placeholder="80 40 80 120" />
          <input id="notifyFade" type="number" min="0" max="200" step="10" value="0" style="width:80px;" />
          <input id="notifyRepeat" type="number" min="1" max="10" step="1" value="1" style="width:70px;" />
          <button id="btnNotify">Notify</button>
          <button id="btnNotifyStop">Stop</button>
        </div>
      </div>
      <div class="row" style="gap:0.35rem; flex-wrap:wrap;">
        <button class="notifyPreset" data-seq="80 40 80 120" data-fade="0">Short blink</button>
        <button class="notifyPreset" data-seq="200 100" data-fade="100">Soft alert</button>
        <button class="notifyPreset" data-seq="120 80 120 80 120 200" data-fade="40">Triple pulse</button>
        <button class="notifyPreset" data-seq="200 80 200 400" data-fade="30">Doorbell</button>
        <button class="notifyPreset" data-seq="500 300" data-fade="120">Long Fade Alert</button>
        <button class="notifyPreset" data-seq="60 60 60 200" data-fade="0">Double 60</button>
      </div>
      <div class="row" style="gap:0.5rem; align-items:center;">
        <div class="input-group" style="max-width:220px;">
          <input id="wakeSec" type="number" min="5" max="600" step="5" value="180" />
          <button id="btnWake">Wake</button>
        </div>
        <div class="input-group" style="max-width:220px;">
          <input id="sleepMin" type="number" min="1" max="240" step="1" value="15" />
          <button id="btnSleep">Sleep</button>
        </div>
        <button id="btnWakeStop">Wake stop</button>
        <button id="btnSleepStop">Sleep stop</button>
      </div>
      <p style="color:var(--muted); margin:0.2rem 0 0;">Enter durations in ms, optional fade=NN</p>
    </div>

    <div class="card">
      <h3>Custom</h3>
      <div class="row">
        <div class="input-group">
          <input id="customStep" type="number" min="100" max="5000" step="50" value="800" />
          <button id="btnCustomStep">Set Step</button>
        </div>
      </div>
      <h4 style="margin-bottom:0.3rem;">Pattern Editor</h4>
      <div id="customEditor"></div>
      <div class="row" style="gap:0.5rem;">
        <button id="btnCustomAdd">Add Point</button>
        <button id="btnCustomClear">Clear</button>
        <button id="btnCustomSend">Send Custom</button>
      </div>
      <label>CSV values (0..1)</label>
      <textarea id="customCsv" rows="4" style="width:100%;"></textarea>
    </div>

    <div class="card">
      <h3>Settings</h3>
      <div class="row" style="align-items:flex-start; flex-direction: column;">
        <label style="min-width:120px;">Quick tap modes:</label>
        <div id="quickList" class="row" style="flex:1; gap:0.05rem;"></div>
        <div class="row" style="gap:0.4rem; align-items:center; margin-top:0.3rem; flex-wrap:wrap;">
          <button id="btnQuickAll">All</button>
          <button id="btnQuickNone">None</button>
          <button id="btnQuickDefault">Default</button>
          <button id="btnQuickApply" title="Applies selection for fast switch tap cycling">Apply</button>
        </div>
      </div>
      <div class="row">
        <label>IdleOff (min, 0=off)</label>
        <div class="input-group">
          <input id="idleMin" type="number" min="0" max="180" step="1" value="0" />
          <button id="btnIdle">Set</button>
        </div>
      </div>
      <div class="row" style="align-items:flex-start;">
        <div class="input-group" style="flex:1;">
          <textarea id="importArea" rows="2" style="flex:1; min-width:180px;" placeholder="paste cfg export here"></textarea>
          <button id="btnImport">Import cfg</button>
        </div>
      </div>
      <div class="row">
        <button id="btnFactory" style="background:#2b0d0d; border-color:#a33; color:#fdd;">Factory Reset</button>
      </div>
    </div>
    <div class="card">
      <h3>Profiles</h3>
      <div class="row" style="gap:0.5rem; align-items:center; flex-wrap:wrap;">
        <label>Slot</label>
        <select id="profileSlot">
          <option value="1">1</option>
          <option value="2">2</option>
          <option value="3">3</option>
        </select>
        <button id="btnProfileSave">Save</button>
        <button id="btnProfileLoad">Load</button>
        <button id="btnProfileExport">Export</button>
        <button id="btnProfileImport">Import</button>
      </div>
      <label>Profile blob (cfg import ...)</label>
      <textarea id="profileBlob" rows="3" style="width:100%;" placeholder="cfg import bri=..."></textarea>
      <p style="color:var(--muted); margin:0.35rem 0 0;">Export loads the slot, then captures cfg export; Import applies blob and saves to slot.</p>
      <div class="row" style="gap:0.4rem; align-items:center;">
        <button id="btnProfileQR">Show QR</button>
        <img id="profileQRImg" alt="Profile QR" style="width:140px; height:140px; border:1px solid var(--border); border-radius:8px; display:none;" />
      </div>
    </div>
    <div class="card">
      <h3 style="display:flex; align-items:center; gap:0.6rem; justify-content:space-between;">
        <span>Presence</span>
        <label class="pill" style="cursor:pointer; margin:0;">
          <input type="checkbox" id="presenceToggle" style="margin-right:0.35rem;" />Presence
        </label>
      </h3>
      <div class="row" style="gap:0.6rem; align-items:center;">
        <span id="presenceStatus" style="color:var(--muted);">Last seen: n/a</span>
        <select id="presenceKnown" style="min-width:170px;">
          <option value="">recent devices</option>
        </select>
        <button id="btnPresenceUse">Use</button>
        <button id="btnPresenceRefresh">Refresh</button>
      </div>
      <div class="row">
        <div class="input-group">
          <input id="presenceMac" type="text" placeholder="AA:BB:CC:DD:EE:FF" size="20" />
          <button id="btnPresenceSet">Set</button>
          <button id="btnPresenceClear" data-cmd="presence clear" style="border-radius:0 6px 6px 0;">Clear</button>
        </div>
      </div>
    </div>

    <div class="card">
      <h3 style="display:flex; align-items:center; gap:0.6rem; justify-content:space-between;">
        <span>Touch</span>
        <label class="pill" style="cursor:pointer; margin:0;">
          <input type="checkbox" id="touchDimToggle" style="margin-right:0.35rem;" />TouchDim
        </label>
      </h3>
      <div class="row">
        <span class="status-chip" id="touchDetail">base -- | raw -- | delta -- | thr --/--</span>
      </div>
      <div class="row">
        <label>Touch hold (ms)</label>
        <div class="input-group">
          <input id="touchHold" type="number" min="500" max="5000" step="100" value="1000" />
          <button id="btnTouchHold">Set</button>
        </div>
      </div>
      <div class="row">
        <label>Touch On</label>
        <div class="input-group" style="max-width:170px;">
          <input id="touchOn" type="number" min="1" max="200" step="1" value="10" />
          <button id="btnTouchTune">Set</button>
        </div>
        <label>Touch Off</label>
        <div class="input-group" style="max-width:170px;">
          <input id="touchOff" type="number" min="1" max="200" step="1" value="6" />
          <button id="btnTouchTuneOff">Set</button>
        </div>
      </div>
      <div class="row">
        <button id="btnCalibTouch">calibrate touch</button>
        <button id="btnCalib">calibrate baseline</button>
      </div>
    </div>


    <div class="card"  id="lightCard" style="display:none;">
      <h3>Light Sensor</h3>
      <div class="row" style="align-items:center; gap:0.5rem;">
        <label class="pill" style="cursor:pointer; margin:0;">
          <input type="checkbox" id="lightToggle" style="margin-right:0.35rem;" />Light Auto
        </label>
        <span class="status-chip">Light: <span id="lightState">--</span></span>
        <button id="btnLightCalib">Calibrate</button>
      </div>
      <div class="slider-group">
        <div class="slider-top">
          <span>Gain</span>
          <input id="lightGainNum" class="slider-number" type="number" min="0.1" max="5" step="0.1" value="1.0" />
        </div>
        <div class="slider-row">
          <input id="lightGain" type="range" min="0.1" max="5" step="0.1" value="1.0" />
        </div>
      </div>
      <div class="slider-group">
        <div class="slider-top">
          <span>Clamp Min</span>
          <input id="lightClampMinNum" class="slider-number" type="number" min="0" max="1.2" step="0.01" value="0.20" />
        </div>
        <div class="slider-row">
          <input id="lightClampMin" type="range" min="0" max="1.2" step="0.01" value="0.20" />
        </div>
      </div>
      <div class="slider-group">
        <div class="slider-top">
          <span>Clamp Max</span>
          <input id="lightClampMaxNum" class="slider-number" type="number" min="0" max="1.5" step="0.01" value="1.00" />
        </div>
        <div class="slider-row">
          <input id="lightClampMax" type="range" min="0" max="1.5" step="0.01" value="1.00" />
        </div>
      </div>
    </div>

    <div class="card"  id="musicCard" style="display:none;">
      <h3>Music Mode</h3>
      <div class="row" style="align-items:center; gap:0.5rem;">
        <label class="pill" style="cursor:pointer; margin:0;">
          <input type="checkbox" id="musicToggle" style="margin-right:0.35rem;" />Music
        </label>
        <span class="status-chip">Music: <span id="musicState">--</span></span>
      </div>
      <div class="slider-group">
        <div class="slider-top">
          <span>Sensitivity</span>
          <input id="musicGainNum" class="slider-number" type="number" min="0.1" max="5" step="0.1" value="1.0" />
        </div>
        <div class="slider-row">
          <input id="musicGain" type="range" min="0.1" max="5" step="0.1" value="1.0" />
        </div>
      </div>
      <p style="color:var(--muted); margin:0.2rem 0 0;">Toggles audio-reactive pattern (if built).</p>
    </div>

  </div>

  <div class="row" style="align-items:center; justify-content:space-between;">
    <h3 style="margin:0;">Log</h3>
    <div class="row" style="gap:0.4rem;">
      <label class="pill" style="cursor:pointer; margin:0;">
        <input type="checkbox" id="liveLogToggle" style="margin-right:0.35rem;" checked />Live log
      </label>
      <button id="btnStatus">Status</button>
      <button id="btnCfgExport">cfg export</button>
    </div>
  </div>
  <div class="log-block">
    <pre id="log"></pre>
    <div class="row log-row" style="margin:0;">
      <input id="cmdInput" type="text" placeholder="type command" style="flex:1; min-width:200px;" />
      <button id="btnSend">Send</button>
    </div>
  </div>

  <div class="grid" style="margin-top:1rem;">
    <div class="card">
      <h3>BLE GUIDs</h3>
      <table class="info-table">
        <thead><tr><th>Label</th><th>Value</th><th>Copy</th></tr></thead>
        <tbody id="guidTable"></tbody>
      </table>
    </div>
    <div class="card">
      <h3>Command Reference & Links</h3>
      <table class="info-table">
        <thead><tr><th>Command</th><th>Description</th></tr></thead>
        <tbody>
          <tr><td>on / off / toggle</td><td>Switch lamp power</td></tr>
          <tr><td>mode N / next / prev</td><td>Select pattern</td></tr>
          <tr><td>auto on|off</td><td>Auto-cycle patterns</td></tr>
          <tr><td>bri X</td><td>Brightness 0..100%</td></tr>
          <tr><td>notify d1 d2 ... [fade=ms]</td><td>Blink pattern (ms)</td></tr>
          <tr><td>quick 1,2,...</td><td>Set fast-switch cycle list</td></tr>
          <tr><td>pat scale 0.1-5</td><td>Pattern speed factor</td></tr>
          <tr><td>touchdim on|off</td><td>Enable touch dimming</td></tr>
          <tr><td>touch tune on off</td><td>Set touch thresholds</td></tr>
          <tr><td>ramp MS / idle MIN</td><td>Ramp and auto-off</td></tr>
          <tr><td>profile save/load</td><td>Store/recall profiles (no touch/presence/quick)</td></tr>
          <tr><td>presence on|off|set|clear</td><td>Presence control</td></tr>
          <tr><td>wake [s] / sleep [m]</td><td>Start fades</td></tr>
          <tr><td>custom ...</td><td>Custom pattern CSV</td></tr>
          <tr><td>cfg export / import</td><td>Backup/restore settings</td></tr>
          <tr><td>status / help</td><td>Show status or commands</td></tr>
        </tbody>
      </table>
      <div class="row" style="margin-top:0.6rem;">
        <a class="pill" href="https://play.google.com/store/apps/details?id=net.dinglisch.android.taskerm" target="_blank" rel="noopener">Tasker (Play Store)</a>
        <a class="pill" href="https://github.com/Haschtl/Tasker-Ble-Writer/actions" target="_blank" rel="noopener">Tasker-BLE-Writer Actions</a>
    <a class="pill" href="https://github.com/Haschtl/Steinlampe/actions/workflows/ci.yml" target="_blank" rel="noopener">Firmware Build (Actions)</a>
      </div>
    </div>
  </div>

  <script>
    const SERVICE = 'd94d86d7-1eaf-47a4-9d1e-7a90bf34e66b';
    const CMD_CHAR = '4bb5047d-0d8b-4c5e-81cd-6fb5c0d1d1f7';
    const STATUS_CHAR = 'c5ad78b6-9b77-4a96-9a42-8e6e9a40c123';
    const PATTERN_LABELS = [
      'Konstant', 'Atmung', 'Pulsierend', 'Funkeln', 'Kerze Soft',
      'Kerze', 'Lagerfeuer', 'Stufen', 'Zwinkern', 'Custom', 'Musik'
    ];
    const PROFILE_SLOTS = 3;

    let cmdChar = null;
    let statusChar = null;
    let device = null;
    let reconnecting = false;
    let serialPort = null;
    let serialWriter = null;
    let serialReader = null;
    let lastCmdText = '';
    let lastCmdTime = 0;
    let lastPresenceTs = 0;
    const presenceHistory = new Set();
    let pendingProfileExport = null;
    let lastCfgExport = '';
    let patternCount = PATTERN_LABELS.length;

    const logEl = document.getElementById('log');
    let liveLogEnabled = true;
    let lastLogLine = '';
    let lastLogMs = 0;
    function log(msg) {
      if (!liveLogEnabled) return;
      const now = Date.now();
      if (msg === lastLogLine && (now - lastLogMs) < 400) {
        return; // dedupe bursts
      }
      lastLogLine = msg;
      lastLogMs = now;
      const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      logEl.textContent += line;
      logEl.scrollTop = logEl.scrollHeight;
    }

    async function connect() {
      if (!navigator.bluetooth) {
        log('Web Bluetooth not supported or not available (needs Chrome/Edge over HTTPS/localhost; enable chrome://flags/#enable-experimental-web-platform-features on some platforms).');
        return;
      }
      try {
        let reqOpts = { filters: [{ services: [SERVICE] }], optionalServices: [SERVICE] };
        try {
          device = await navigator.bluetooth.requestDevice(reqOpts);
        } catch (e1) {
          log('Filter request failed, trying acceptAllDevices...');
          device = await navigator.bluetooth.requestDevice({ acceptAllDevices: true, optionalServices: [SERVICE] });
        }

        log('Connecting...');
        const server = await device.gatt.connect();
        device.addEventListener('gattserverdisconnected', async () => {
          log('Disconnected');
          document.getElementById('status').textContent = 'Disconnected';
          if (document.getElementById('autoReconnect').checked && device) {
            reconnecting = true;
            try {
              log('Reconnecting...');
              await device.gatt.connect();
              log('Reconnected');
              document.getElementById('status').textContent = 'Connected to ' + device.name;
            } catch (e) {
              log('Reconnect failed: ' + e);
            } finally {
              reconnecting = false;
            }
          }
        });
        log('Discover service');
        const service = await server.getPrimaryService(SERVICE);

        // List available characteristics for debugging
        try {
          const chars = await service.getCharacteristics();
          log('Found chars: ' + chars.map(c => c.uuid).join(', '));
        } catch (e) {
          log('Could not list characteristics: ' + e);
        }

        log('Discover cmd/status chars');
        try {
          cmdChar = await service.getCharacteristic(CMD_CHAR);
        } catch (e) {
          log('Cmd char not found: ' + e);
          throw e;
        }
        try {
          statusChar = await service.getCharacteristic(STATUS_CHAR);
        } catch (e) {
          log('Status char not found: ' + e);
          throw e;
        }

        let notified = false;
        // Attach notifications on cmdChar (firmware sends feedback here)
        if (cmdChar && cmdChar.properties && cmdChar.properties.notify) {
          try {
            await cmdChar.startNotifications();
            cmdChar.addEventListener('characteristicvaluechanged', onNotify);
            log('Cmd notify enabled');
          } catch (e) {
            log('Cmd notify not available: ' + e);
          }
        }

        // Attach notifications on statusChar (UI updates only, no log to avoid duplicates)
        if (statusChar && statusChar.properties && statusChar.properties.notify) {
          try {
            await statusChar.startNotifications();
            statusChar.addEventListener('characteristicvaluechanged', (ev) => {
              const txt = new TextDecoder().decode(ev.target.value || new DataView());
              txt.split(/\r?\n/).forEach(line => updateUIFromStatus(line.trim()));
            });
            log('Status notify enabled');
            notified = true;
          } catch (e) {
            log('Status notify not available; using read fallback');
          }
        } else {
          log('Status notify not supported by firmware');
        }

        if (statusChar && !notified) {
          try {
            const val = await statusChar.readValue();
            const txt = new TextDecoder().decode(val || new DataView());
            txt.split(/\r?\n/).forEach(line => updateUIFromStatus(line.trim()));
          } catch (e2) {
            log('Status read failed: ' + e2);
          }
        }
        document.getElementById('status').textContent = 'Connected to ' + device.name;
        log('Connected to ' + device.name);
        sendCmd('status');
        setTimeout(() => sendCmd('status'), 300);
      } catch (e) {
        log('Connect error: ' + e);
      }
    }

    async function connectSerial() {
      if (!('serial' in navigator)) {
        log('Web Serial not supported (needs Chrome/Edge over HTTPS/localhost)');
        return;
      }
      try {
        serialPort = await navigator.serial.requestPort();
        await serialPort.open({ baudRate: 115200 });
        const encoder = new TextEncoderStream();
        serialWriter = encoder.writable.getWriter();
        encoder.readable.pipeTo(serialPort.writable);

        const reader = serialPort.readable.getReader();
        const decoder = new TextDecoder();
        serialReader = reader;
        let buffer = '';
        log('Serial connected');
        document.getElementById('status').textContent = 'Serial connected';
        (async () => {
          try {
            while (true) {
              const { value, done } = await reader.read();
              if (done) break;
              buffer += decoder.decode(value, { stream: true });
              let idx;
              while ((idx = buffer.indexOf('\n')) >= 0) {
                const line = buffer.slice(0, idx).trim();
                buffer = buffer.slice(idx + 1);
                if (line) {
                  log(line);
                  onNotify({ target: { value: new TextEncoder().encode(line) } });
                }
              }
            }
          } catch (e) {
            log('Serial read error: ' + e);
          } finally {
            reader.releaseLock();
            serialReader = null;
            serialWriter = null;
            if (serialPort) await serialPort.close();
            serialPort = null;
            document.getElementById('status').textContent = 'Disconnected';
          }
        })();
      } catch (e) {
        log('Serial connect error: ' + e);
      }
    }

    function onNotify(e) {
      const txt = new TextDecoder().decode(e.target.value || new DataView());
      txt.split(/\r?\n/).forEach(line => {
        if (line.trim()) log(line.trim());
        updateUIFromStatus(line.trim());
      });
    }

    function updateUIFromStatus(line) {
      if (!line) return;
      const lastStatusEl = document.getElementById('lastStatus');
      if (lastStatusEl) lastStatusEl.textContent = 'Last status: ' + new Date().toLocaleTimeString();
      // Lamp state + brightness
    if (line.includes('Lamp=')) {
      const m = line.match(/Brightness=([0-9.]+)/);
      if (m) {
        const val = Math.round(parseFloat(m[1]));
        const bri = document.getElementById('bri');
        const briNum = document.getElementById('briNum');
        const briVal = document.getElementById('briVal');
        if (!Number.isNaN(val)) {
          bri.value = val;
          briVal.textContent = val;
          if (briNum) briNum.value = val;
        }
      }
      const lampState = line.match(/Lamp=([A-Z]+)/);
      const switchState = line.match(/Switch=([A-Z]+)/);
      const statusEl = document.getElementById('status');
      if (lampState && statusEl) statusEl.textContent = `Lamp ${lampState[1]}`;
      const lampToggle = document.getElementById('lampToggle');
      if (lampToggle && lampState) lampToggle.checked = (lampState[1] === 'ON');
      const switchSpan = document.getElementById('switchState');
      if (switchSpan && switchState) switchSpan.textContent = switchState[1];
    }
      // AutoCycle toggle from pattern line
      if (line.startsWith('Pattern ')) {
        const autoChk = document.getElementById('autoToggle');
        if (autoChk) autoChk.checked = line.includes('AutoCycle=ON');
        const speedMatch = line.match(/Speed=([0-9.]+)/);
        if (speedMatch) {
          const v = parseFloat(speedMatch[1]);
          const inp = document.getElementById('patSpeed');
          const num = document.getElementById('patSpeedNum');
          if (!Number.isNaN(v)) {
            if (inp) inp.value = v;
            if (num) num.value = v.toFixed(1);
          }
        }
        const modeMatch = line.match(/Pattern\s+(\d+)\/(\d+)/);
        if (modeMatch) {
          const idx = parseInt(modeMatch[1], 10);
          const total = parseInt(modeMatch[2], 10);
          if (!Number.isNaN(total) && total > 0) {
            patternCount = total;
            populateModes();
            renderQuickModes(getQuickSelection());
          }
          const sel = document.getElementById('modeSelect');
          if (sel && !Number.isNaN(idx)) sel.value = String(idx);
          window.currentPatternIndex = idx;
          window.patternCount = patternCount;
        }
      }
      if (line.startsWith('[Quick]')) {
        const csv = line.replace('[Quick]', '').trim();
        if (csv) {
          const parts = csv.toLowerCase() === 'none' ? [] : csv.split(',').map(x => parseInt(x.trim(), 10)).filter(n => !Number.isNaN(n));
          setQuickSelection(parts);
        }
      }
      if (line.startsWith('[Light]')) {
        const chip = document.getElementById('lightState');
        if (chip) {
          if (line.includes('N/A')) {
            chip.textContent = 'N/A';
            chip.style.color = 'var(--muted)';
          } else {
            const raw = line.match(/raw=([0-9]+)/);
            chip.textContent = 'ON' + (raw ? ` (${raw[1]})` : '');
            chip.style.color = '#8cf59b';
          }
        }
        const lt = document.getElementById('lightToggle');
    if (lt) lt.checked = !line.includes('N/A') && (line.includes('en=1') || line.includes('Enabled') || line.includes('ON'));
    const lc = document.getElementById('lightCard');
    if (lc) lc.style.display = line.includes('N/A') ? 'none' : 'block';
    // Hide duplicated status chip if card is visible
    if (lc && lc.style.display !== 'none' && chip && chip.closest('.status-chip')) {
      chip.closest('.status-chip').style.display = 'none';
    }
        const lmin = document.getElementById('lightClampMin');
        const lmax = document.getElementById('lightClampMax');
        const lminNum = document.getElementById('lightClampMinNum');
        const lmaxNum = document.getElementById('lightClampMaxNum');
        if (lmin && lmin.value === '') lmin.value = '0.20';
        if (lmax && lmax.value === '') lmax.value = '1.00';
        if (lminNum && lminNum.value === '') lminNum.value = '0.20';
        if (lmaxNum && lmaxNum.value === '') lmaxNum.value = '1.00';
      }
      if (line.startsWith('[Music]')) {
        const chip = document.getElementById('musicState');
        if (chip) {
          if (line.includes('N/A')) {
            chip.textContent = 'N/A';
            chip.style.color = 'var(--muted)';
          } else {
            chip.textContent = line.includes('ON') ? 'ON' : 'OFF';
            chip.style.color = line.includes('ON') ? '#8cf59b' : 'var(--muted)';
          }
        }
        const mt = document.getElementById('musicToggle');
        if (mt) mt.checked = line.includes('ON');
        const mc = document.getElementById('musicCard');
        if (mc) mc.style.display = line.includes('N/A') ? 'none' : 'block';
        if (mc && mc.style.display !== 'none' && chip && chip.closest('.status-chip')) {
          chip.closest('.status-chip').style.display = 'none';
        }
      }
      // Presence address hint
      if (line.startsWith('Presence=')) {
        const addrMatch = line.match(/\(([^)]+)\)/);
        const input = document.getElementById('presenceMac');
        if (addrMatch && addrMatch[1] && input && !input.value) {
          input.value = addrMatch[1];
        }
        const pT = document.getElementById('presenceToggle');
        if (pT) pT.checked = line.includes('Presence=ON');
        const pStatus = document.getElementById('presenceStatus');
        const known = document.getElementById('presenceKnown');
        if (pStatus) {
          lastPresenceTs = Date.now();
          pStatus.textContent = 'Last seen: just now';
        }
        if (addrMatch && addrMatch[1] && known) {
          presenceHistory.add(addrMatch[1]);
          known.innerHTML = '<option value=\"\">recent devices</option>' + Array.from(presenceHistory).map(a => `<option value="${a}">${a}</option>`).join('');
        }
      }
      if (line.startsWith('[Touch]')) {
        const baseMatch = line.match(/base=([-0-9]+)/);
        const rawMatch = line.match(/raw=([-0-9]+)/);
        const deltaMatch = line.match(/delta=([-0-9]+)/);
        const thrOn = line.match(/thrOn=([-0-9]+)/);
        const thrOff = line.match(/thrOff=([-0-9]+)/);
        const active = line.includes('active=1');
        const touchState = document.getElementById('touchState');
        if (touchState) {
          touchState.textContent = active ? 'TOUCH' : 'idle';
          touchState.style.color = active ? '#8cf59b' : 'var(--muted)';
        }
        const touchDetail = document.getElementById('touchDetail');
        if (touchDetail) {
          touchDetail.textContent = `base ${baseMatch ? baseMatch[1] : '--'} | raw ${rawMatch ? rawMatch[1] : '--'} | delta ${deltaMatch ? deltaMatch[1] : '--'} | thr ${thrOn ? thrOn[1] : '--'}/${thrOff ? thrOff[1] : '--'}`;
        }
      }
      // cfg export capture (for profile export helper)
      if (line.startsWith('cfg import')) {
        lastCfgExport = line.trim();
        const blob = document.getElementById('profileBlob');
        if (pendingProfileExport && blob) {
          blob.value = lastCfgExport;
          log('Captured profile export: ' + lastCfgExport);
          pendingProfileExport = null;
        }
      }
      // Ramp/Idle/TouchDim
      if (line.startsWith('Ramp=')) {
        const r = line.match(/Ramp=([0-9]+)/);
        if (r) document.getElementById('rampMs').value = r[1];
        const i = line.match(/IdleOff=([0-9]+)m|IdleOff=off/);
        if (i) {
          const v = i[0].includes('off') ? 0 : parseInt(i[1]);
          document.getElementById('idleMin').value = v;
        }
        const td = document.getElementById('touchDimToggle');
        if (td) td.checked = line.includes('TouchDim=ON');
        const pf = document.getElementById('patFadeToggle');
        const pfVal = document.getElementById('patFadeVal');
        const pfAmt = document.getElementById('patFadeAmt');
        const pfNum = document.getElementById('patFadeNum');
        const m = line.match(/PatFade=([A-Z]+)\(([0-9.]+)/);
        if (pf) pf.checked = line.includes('PatFade=ON');
        if (m && pfVal && pfAmt) {
          const v = parseFloat(m[2]);
          if (!Number.isNaN(v)) {
            pfVal.textContent = v.toFixed(2);
            pfAmt.value = v;
            if (pfNum) pfNum.value = v.toFixed(2);
          }
        }
        const reOn = line.match(/RampOn=([a-zA-Z-]+)\(([0-9.]+)\)/);
        const reOff = line.match(/RampOff=([a-zA-Z-]+)\(([0-9.]+)\)/);
        const selOn = document.getElementById('rampEaseOn');
        const selOff = document.getElementById('rampEaseOff');
        const powOn = document.getElementById('rampPowOn');
        const powOff = document.getElementById('rampPowOff');
        if (reOn) {
          if (selOn) selOn.value = reOn[1].toLowerCase();
          if (powOn) powOn.value = parseFloat(reOn[2]).toFixed(2);
        }
        if (reOff) {
          if (selOff) selOff.value = reOff[1].toLowerCase();
          if (powOff) powOff.value = parseFloat(reOff[2]).toFixed(2);
        }
      }
    }

    function currentModeNames() {
      const names = PATTERN_LABELS.slice(0, patternCount);
      for (let i = 1; i <= PROFILE_SLOTS; i++) {
        names.push(`Profile ${i}`);
      }
      return names;
    }

    function populateModes() {
      const sel = document.getElementById('modeSelect');
      sel.innerHTML = '';
      const names = currentModeNames();
      names.forEach((name, idx) => {
        const opt = document.createElement('option');
        opt.value = (idx + 1).toString();
        opt.textContent = `${idx + 1} - ${name}`;
        sel.appendChild(opt);
      });
    }

  // --- Custom pattern editor ---
  let customPoints = [];

  function syncCustomCsvFromPoints() {
    const csv = customPoints.map(v => v.toFixed(3)).join(',');
    const area = document.getElementById('customCsv');
    if (area) area.value = csv;
  }

  function renderCustomEditor() {
    const wrap = document.getElementById('customEditor');
    if (!wrap) return;
    wrap.innerHTML = '';
    customPoints.forEach((v, idx) => {
      const row = document.createElement('div');
      row.className = 'bar-row';
      const range = document.createElement('input');
      range.type = 'range';
      range.min = '0';
      range.max = '1';
      range.step = '0.01';
      range.value = v.toFixed(2);
      const num = document.createElement('input');
      num.type = 'number';
      num.min = '0';
      num.max = '1';
      num.step = '0.01';
      num.value = v.toFixed(2);
      const del = document.createElement('button');
      del.textContent = 'X';
      del.onclick = () => {
        customPoints.splice(idx, 1);
        renderCustomEditor();
        syncCustomCsvFromPoints();
      };
      const syncVal = (nv) => {
        let val = parseFloat(nv);
        if (Number.isNaN(val)) val = 0;
        if (val < 0) val = 0;
        if (val > 1) val = 1;
        customPoints[idx] = val;
        range.value = val;
        num.value = val.toFixed(2);
        syncCustomCsvFromPoints();
      };
      range.oninput = (e) => syncVal(e.target.value);
      num.oninput = (e) => syncVal(e.target.value);
      row.appendChild(range);
      row.appendChild(num);
      row.appendChild(del);
      wrap.appendChild(row);
    });
  }

  function loadPointsFromCsv() {
    const area = document.getElementById('customCsv');
    if (!area) return;
    const csv = area.value.trim();
    if (!csv) {
      customPoints = [];
      renderCustomEditor();
      return;
    }
    const vals = csv.split(',').map(s => parseFloat(s));
    customPoints = vals.filter(v => !Number.isNaN(v)).map(v => {
      if (v < 0) return 0;
      if (v > 1) return 1;
      return v;
    });
    renderCustomEditor();
  }

    function populateGuids() {
      const rows = [
        { label: 'Service UUID', value: SERVICE },
        { label: 'Command Char', value: CMD_CHAR },
        { label: 'Status Char', value: STATUS_CHAR },
      ];
      const body = document.getElementById('guidTable');
      body.innerHTML = '';
      rows.forEach(r => {
        const tr = document.createElement('tr');
        const td1 = document.createElement('td'); td1.textContent = r.label;
        const td2 = document.createElement('td'); td2.textContent = r.value;
        const td3 = document.createElement('td');
        const btn = document.createElement('button');
        btn.className = 'copy-btn';
        btn.textContent = 'Copy';
        btn.dataset.copy = r.value;
        td3.appendChild(btn);
        tr.appendChild(td1); tr.appendChild(td2); tr.appendChild(td3);
        body.appendChild(tr);
      });
    }

    function defaultQuickIndices() {
      const out = [];
      currentModeNames().forEach((name, idx) => {
        if (idx < 3) out.push(idx + 1);
        if (name.toLowerCase().includes('musik'))
          out.push(idx + 1);
      });
      return Array.from(new Set(out));
    }

    function renderQuickModes(selected = defaultQuickIndices()) {
      const wrap = document.getElementById('quickList');
      wrap.innerHTML = '';
      currentModeNames().forEach((name, idx) => {
        const lbl = document.createElement('label');
        lbl.className = 'quick-label';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.className = 'quickCb';
        cb.value = (idx + 1).toString();
        if (selected.includes(idx + 1)) cb.checked = true;
        lbl.appendChild(cb);
        const txt = document.createElement('span');
        txt.textContent = `${idx + 1}. ${name}`;
        lbl.appendChild(txt);
        wrap.appendChild(lbl);
      });
    }

    function getQuickSelection() {
      return Array.from(document.querySelectorAll('.quickCb'))
        .filter(cb => cb.checked)
        .map(cb => parseInt(cb.value, 10))
        .filter(n => !Number.isNaN(n));
    }

    function setQuickSelection(indices, useDefaultWhenEmpty = false) {
      const idxSet = (!indices || indices.length === 0) ? new Set(useDefaultWhenEmpty ? defaultQuickIndices() : []) : new Set(indices);
      document.querySelectorAll('.quickCb').forEach(cb => {
        cb.checked = idxSet.has(parseInt(cb.value, 10));
      });
    }

  async function sendCmd(text) {
      lastCmdText = text;
      lastCmdTime = Date.now();
    if (serialWriter) {
      try {
        await serialWriter.write(text + "\n");
        log('> ' + text + ' (serial)');
        return;
        } catch (e) {
          log('Serial send error: ' + e);
        }
      }

      if (!cmdChar) {
        log('Not connected');
        return;
      }
      try {
        const payload = new TextEncoder().encode(text + '\n');
        await cmdChar.writeValueWithoutResponse(payload);
        log('> ' + text);
      } catch (e) {
        log('Send error: ' + e);
      }
    }

    document.getElementById('btnConnect').onclick = connect;
    document.querySelectorAll('button[data-cmd]').forEach(btn => {
      btn.onclick = () => {
        sendCmd(btn.dataset.cmd);
        if (btn.dataset.cmd === 'next' || btn.dataset.cmd === 'prev') {
          if (window.currentPatternIndex && window.patternCount) {
            let idx = window.currentPatternIndex;
            if (btn.dataset.cmd === 'next') idx = (idx % window.patternCount) + 1;
            else idx = (idx - 2 + window.patternCount) % window.patternCount + 1;
            const sel = document.getElementById('modeSelect');
            if (sel) sel.value = String(idx);
            window.currentPatternIndex = idx;
          }
        }
      };
    });
    document.getElementById('btnSerial').onclick = connectSerial;
    document.getElementById('btnSend').onclick = () => {
      const txt = document.getElementById('cmdInput').value.trim();
      if (txt) sendCmd(txt);
    };
    const briRange = document.getElementById('bri');
    const briNum = document.getElementById('briNum');
    const briVal = document.getElementById('briVal');
    document.getElementById('btnStatus').onclick = () => {
      const now = Date.now();
      if (lastCmdText === 'off' && now - lastCmdTime < 300) {
        setTimeout(() => sendCmd('status'), 250);
      } else {
        sendCmd('status');
      }
    };
    const syncBri = (v, send = false) => {
      if (briRange) briRange.value = v;
      if (briNum) briNum.value = v;
      if (briVal) briVal.textContent = v;
      if (send) sendCmd('bri ' + v);
    };
    if (briRange) {
      briRange.oninput = e => syncBri(e.target.value);
      briRange.onchange = e => syncBri(e.target.value, true);
    }
    if (briNum) {
      briNum.oninput = e => syncBri(e.target.value);
      briNum.onchange = e => syncBri(e.target.value, true);
    }

    document.getElementById('btnPresenceSet').onclick = () => {
      const mac = document.getElementById('presenceMac').value.trim();
      if (mac) sendCmd('presence set ' + mac);
    };
    const btnPresenceUse = document.getElementById('btnPresenceUse');
    if (btnPresenceUse) {
      btnPresenceUse.onclick = () => {
        const sel = document.getElementById('presenceKnown');
        if (sel && sel.value) {
          document.getElementById('presenceMac').value = sel.value;
          sendCmd('presence set ' + sel.value);
        }
      };
    }
    const btnPresenceRefresh = document.getElementById('btnPresenceRefresh');
    if (btnPresenceRefresh) btnPresenceRefresh.onclick = () => sendCmd('status');
    // auto status every 10s
    setInterval(() => {
      if (cmdChar || serialWriter) sendCmd('status');
    }, 10000);
    document.getElementById('btnStatus').onclick = () => sendCmd('status');
    document.getElementById('btnCfgExport').onclick = () => sendCmd('cfg export');
    const liveLogToggle = document.getElementById('liveLogToggle');
    if (liveLogToggle) liveLogToggle.onchange = (e) => { liveLogEnabled = e.target.checked; };
    document.getElementById('modeSelect').onchange = (e) => {
      const val = e.target.value;
      if (val) {
        if (val.startsWith('profile-')) {
          const slot = val.split('-')[1];
          sendCmd('profile load ' + slot);
        } else {
          sendCmd('mode ' + val);
        }
      }
    };
    document.getElementById('autoToggle').onchange = (e) => {
      sendCmd(e.target.checked ? 'auto on' : 'auto off');
    };
    const patSpeedEl = document.getElementById('patSpeed');
    const patSpeedNum = document.getElementById('patSpeedNum');
    const syncPatSpeed = (v, send = false) => {
      if (patSpeedEl) patSpeedEl.value = v;
      if (patSpeedNum) patSpeedNum.value = v;
      if (send) sendCmd('pat scale ' + v);
    };
    if (patSpeedEl) {
      patSpeedEl.oninput = (e) => syncPatSpeed(e.target.value);
      patSpeedEl.onchange = (e) => syncPatSpeed(e.target.value, true);
    }
    if (patSpeedNum) {
      patSpeedNum.oninput = (e) => syncPatSpeed(e.target.value);
      patSpeedNum.onchange = (e) => syncPatSpeed(e.target.value, true);
    }
    const easeSample = (t, type, pow) => {
      t = Math.max(0, Math.min(1, t));
      switch (type) {
        case 'linear': return t;
        case 'ease-in': return Math.pow(t, pow);
        case 'ease-out': return 1 - Math.pow(1 - t, pow);
        case 'ease-in-out': {
          const p = pow;
          return t < 0.5 ? 0.5 * Math.pow(t * 2, p) : 1 - 0.5 * Math.pow((1 - t) * 2, p);
        }
        case 'ease':
        default: return t * t * (3 - 2 * t);
      }
    };
    const drawRampPreview = (svgId, typeSel, powInput) => {
      const svg = document.getElementById(svgId);
      const type = typeSel ? typeSel.value : 'ease';
      const pow = powInput ? parseFloat(powInput.value || '2') : 2;
      if (!svg) return;
      const w = 100, h = 50;
      let path = '';
      for (let i = 0; i <= 20; i++) {
        const t = i / 20;
        const y = easeSample(t, type, pow);
        const px = (t * w).toFixed(2);
        const py = (h - y * h).toFixed(2);
        path += (i === 0 ? 'M' : 'L') + px + ' ' + py + ' ';
      }
      svg.innerHTML = `<path d="${path}" stroke="#5be6ff" stroke-width="2" fill="none"/>`;
    };

    populateModes();
    renderQuickModes();
    populateGuids();
    loadPointsFromCsv();
    const tdToggle = document.getElementById('touchDimToggle');
    if (tdToggle) {
      tdToggle.onchange = (e) => sendCmd(e.target.checked ? 'touchdim on' : 'touchdim off');
    }
    const lampToggle = document.getElementById('lampToggle');
    if (lampToggle) {
      const lampHandler = (e) => sendCmd(e.target.checked ? 'on' : 'off');
      lampToggle.oninput = lampHandler;
      lampToggle.onclick = lampHandler;
    }
    const presToggle = document.getElementById('presenceToggle');
    if (presToggle) {
      presToggle.onchange = (e) => sendCmd(e.target.checked ? 'presence on' : 'presence off');
    }
    const pfToggle = document.getElementById('patFadeToggle');
    const pfAmt = document.getElementById('patFadeAmt');
    const pfVal = document.getElementById('patFadeVal');
    const pfNum = document.getElementById('patFadeNum');
    if (pfToggle) {
      pfToggle.onchange = (e) => sendCmd(e.target.checked ? 'pat fade on' : 'pat fade off');
    }
    const syncPf = (v, send = false) => {
      if (pfVal) pfVal.textContent = Number(v).toFixed(2);
      if (pfAmt) pfAmt.value = v;
      if (pfNum) pfNum.value = v;
      if (send) sendCmd('pat fade amt ' + v);
    };
    if (pfAmt) {
      pfAmt.oninput = (e) => syncPf(e.target.value);
      pfAmt.onchange = (e) => syncPf(e.target.value, true);
      syncPf(pfAmt.value);
    }
    if (pfNum) {
      pfNum.oninput = (e) => syncPf(e.target.value);
      pfNum.onchange = (e) => syncPf(e.target.value, true);
    }
    const rampEaseOn = document.getElementById('rampEaseOn');
    const rampEaseOff = document.getElementById('rampEaseOff');
    const rampPowOn = document.getElementById('rampPowOn');
    const rampPowOff = document.getElementById('rampPowOff');
    if (rampEaseOn) rampEaseOn.onchange = () => { drawRampPreview('rampPrevOn', rampEaseOn, rampPowOn); sendCmd(`ramp ease on ${rampEaseOn.value} ${rampPowOn ? rampPowOn.value : ''}`); };
    if (rampPowOn) rampPowOn.onchange = () => { drawRampPreview('rampPrevOn', rampEaseOn, rampPowOn); sendCmd(`ramp ease on ${rampEaseOn ? rampEaseOn.value : 'ease'} ${rampPowOn.value}`); };
    if (rampEaseOff) rampEaseOff.onchange = () => { drawRampPreview('rampPrevOff', rampEaseOff, rampPowOff); sendCmd(`ramp ease off ${rampEaseOff.value} ${rampPowOff ? rampPowOff.value : ''}`); };
    if (rampPowOff) rampPowOff.onchange = () => { drawRampPreview('rampPrevOff', rampEaseOff, rampPowOff); sendCmd(`ramp ease off ${rampEaseOff ? rampEaseOff.value : 'ease'} ${rampPowOff.value}`); };
    drawRampPreview('rampPrevOn', rampEaseOn, rampPowOn);
    drawRampPreview('rampPrevOff', rampEaseOff, rampPowOff);
    document.getElementById('btnQuickApply').onclick = () => {
      const sel = getQuickSelection();
      sendCmd(sel.length ? ('quick ' + sel.join(',')) : 'quick default');
    };
    const btnQuickAll = document.getElementById('btnQuickAll');
    const btnQuickNone = document.getElementById('btnQuickNone');
    const btnQuickDefault = document.getElementById('btnQuickDefault');
    if (btnQuickAll) btnQuickAll.onclick = () => setQuickSelection(MODE_NAMES.map((_, i) => i + 1));
    if (btnQuickNone) btnQuickNone.onclick = () => setQuickSelection([]);
    if (btnQuickDefault) btnQuickDefault.onclick = () => setQuickSelection(defaultQuickIndices());
    const getProfileSlot = () => parseInt((document.getElementById('profileSlot') || { value: '1' }).value, 10) || 1;
    const btnProfileSave = document.getElementById('btnProfileSave');
    const btnProfileLoad = document.getElementById('btnProfileLoad');
    const btnProfileExport = document.getElementById('btnProfileExport');
    const btnProfileImport = document.getElementById('btnProfileImport');
    if (btnProfileSave) btnProfileSave.onclick = () => sendCmd('profile save ' + getProfileSlot());
    if (btnProfileLoad) btnProfileLoad.onclick = () => sendCmd('profile load ' + getProfileSlot());
    if (btnProfileExport) btnProfileExport.onclick = () => {
      pendingProfileExport = getProfileSlot();
      sendCmd('profile load ' + pendingProfileExport);
      setTimeout(() => sendCmd('cfg export'), 200);
    };
    if (btnProfileImport) btnProfileImport.onclick = () => {
      const blob = (document.getElementById('profileBlob') || {}).value || '';
      const slot = getProfileSlot();
      if (!blob.trim()) return;
      const text = blob.trim().startsWith('cfg import') ? blob.trim() : ('cfg import ' + blob.trim());
      sendCmd(text);
      setTimeout(() => sendCmd('profile save ' + slot), 250);
    };
    const btnProfileQuick1 = document.getElementById('btnProfileQuick1');
    const btnProfileQuick2 = document.getElementById('btnProfileQuick2');
    const btnProfileQuick3 = document.getElementById('btnProfileQuick3');
    if (btnProfileQuick1) btnProfileQuick1.onclick = () => sendCmd('profile load 1');
    if (btnProfileQuick2) btnProfileQuick2.onclick = () => sendCmd('profile load 2');
    if (btnProfileQuick3) btnProfileQuick3.onclick = () => sendCmd('profile load 3');
    document.getElementById('btnTouchHold').onclick = () => {
      const v = document.getElementById('touchHold').value;
      sendCmd('touch hold ' + v);
    };
    document.getElementById('btnRamp').onclick = () => {
      const v = document.getElementById('rampMs').value;
      sendCmd('ramp ' + v);
    };
    document.getElementById('btnIdle').onclick = () => {
      const v = document.getElementById('idleMin').value;
      sendCmd('idle ' + v);
    };
    document.getElementById('btnCustomStep').onclick = () => {
      const v = document.getElementById('customStep').value;
      sendCmd('custom step ' + v);
    };
    const btnNotify = document.getElementById('btnNotify');
    if (btnNotify) {
      btnNotify.onclick = () => {
        const seq = document.getElementById('notifySeq').value.trim();
        const fade = document.getElementById('notifyFade').value.trim();
        const repEl = document.getElementById('notifyRepeat');
        let rep = repEl ? parseInt(repEl.value || '1', 10) : 1;
        if (Number.isNaN(rep) || rep < 1) rep = 1;
        if (rep > 10) rep = 10;
        let cmd = 'notify';
        if (seq) {
          let built = seq;
          if (rep > 1) {
            const parts = seq.split(/\s+/).filter(Boolean);
            built = Array(rep).fill(parts.join(' ')).join(' ');
          }
          cmd += ' ' + built;
        }
        if (fade && parseInt(fade, 10) > 0) cmd += ' fade=' + fade;
        sendCmd(cmd);
      };
    }
    const btnNotifyStop = document.getElementById('btnNotifyStop');
    if (btnNotifyStop) {
      btnNotifyStop.onclick = () => sendCmd('notify stop');
    }
    document.querySelectorAll('.notifyPreset').forEach(btn => {
      btn.onclick = () => {
        const seq = btn.dataset.seq || '';
        const fade = btn.dataset.fade || '';
        const seqEl = document.getElementById('notifySeq');
        const fadeEl = document.getElementById('notifyFade');
        if (seqEl) seqEl.value = seq;
        if (fadeEl && fade.length) fadeEl.value = fade;
        log(`Preset: ${seq}${fade ? ' fade=' + fade : ''}`);
      };
    });
    const btnWake = document.getElementById('btnWake');
    if (btnWake) btnWake.onclick = () => {
      const v = document.getElementById('wakeSec').value || '180';
      sendCmd('wake ' + v);
    };
    const btnSleep = document.getElementById('btnSleep');
    if (btnSleep) btnSleep.onclick = () => {
      const v = document.getElementById('sleepMin').value || '15';
      sendCmd('sleep ' + v);
    };
    const btnWakeStop = document.getElementById('btnWakeStop');
    if (btnWakeStop) btnWakeStop.onclick = () => sendCmd('wake stop');
    const btnSleepStop = document.getElementById('btnSleepStop');
    if (btnSleepStop) btnSleepStop.onclick = () => sendCmd('sleep stop');
    const btnCustomSend = document.getElementById('btnCustomSend');
    if (btnCustomSend) {
      btnCustomSend.onclick = () => {
        syncCustomCsvFromPoints();
        const csv = document.getElementById('customCsv').value.trim();
        if (csv) sendCmd('custom ' + csv);
      };
    }
    const btnCustomAdd = document.getElementById('btnCustomAdd');
    if (btnCustomAdd) {
      btnCustomAdd.onclick = () => {
        customPoints.push(0.5);
        renderCustomEditor();
        syncCustomCsvFromPoints();
      };
    }
    const btnCustomClear = document.getElementById('btnCustomClear');
    if (btnCustomClear) {
      btnCustomClear.onclick = () => {
        customPoints = [];
        renderCustomEditor();
        syncCustomCsvFromPoints();
      };
    }
    const customCsvArea = document.getElementById('customCsv');
    if (customCsvArea) {
      customCsvArea.onchange = loadPointsFromCsv;
    }
    const btnFactory = document.getElementById('btnFactory');
    if (btnFactory) {
      btnFactory.onclick = () => {
        const ok = confirm('Factory reset all settings?');
        if (ok) sendCmd('factory');
      };
    }
    const lt = document.getElementById('lightToggle');
    const lg = document.getElementById('lightGain');
    const lgNum = document.getElementById('lightGainNum');
    if (lt) lt.onchange = (e) => sendCmd(e.target.checked ? 'light on' : 'light off');
    const syncLg = (v, send = false) => {
      if (lg) lg.value = v;
      if (lgNum) lgNum.value = v;
      if (send) sendCmd('light gain ' + v);
    };
    if (lg) {
      lg.oninput = (e) => syncLg(e.target.value);
      lg.onchange = (e) => syncLg(e.target.value, true);
    }
    if (lgNum) {
      lgNum.oninput = (e) => syncLg(e.target.value);
      lgNum.onchange = (e) => syncLg(e.target.value, true);
    }
    const btnLightCalib = document.getElementById('btnLightCalib');
    if (btnLightCalib) btnLightCalib.onclick = () => sendCmd('light calib');
    const mt = document.getElementById('musicToggle');
    if (mt) mt.onchange = (e) => sendCmd(e.target.checked ? 'music on' : 'music off');
    const lmin = document.getElementById('lightClampMin');
    const lmax = document.getElementById('lightClampMax');
    const lminNum = document.getElementById('lightClampMinNum');
    const lmaxNum = document.getElementById('lightClampMaxNum');
    const syncClamp = (fromMin, send = false) => {
      let mn = parseFloat(lmin ? lmin.value : (lminNum ? lminNum.value : '0.2')) || 0;
      let mx = parseFloat(lmax ? lmax.value : (lmaxNum ? lmaxNum.value : '1.0')) || 1;
      if (mn < 0) mn = 0;
      if (mx > 1.5) mx = 1.5;
      if (mn >= mx) mn = Math.max(0, Math.min(mx - 0.01, mn));
      if (lmin) lmin.value = mn;
      if (lmax) lmax.value = mx;
      if (lminNum) lminNum.value = mn;
      if (lmaxNum) lmaxNum.value = mx;
      if (send) sendCmd(`light clamp ${mn.toFixed(2)} ${mx.toFixed(2)}`);
    };
    if (lmin) { lmin.oninput = () => syncClamp(true); lmin.onchange = () => syncClamp(true, true); }
    if (lmax) { lmax.oninput = () => syncClamp(false); lmax.onchange = () => syncClamp(false, true); }
    if (lminNum) { lminNum.oninput = () => syncClamp(true); lminNum.onchange = () => syncClamp(true, true); }
    if (lmaxNum) { lmaxNum.oninput = () => syncClamp(false); lmaxNum.onchange = () => syncClamp(false, true); }
    const mg = document.getElementById('musicGain');
    const mgNum = document.getElementById('musicGainNum');
    const syncMusicGain = (v, send = false) => {
      if (mg) mg.value = v;
      if (mgNum) mgNum.value = v;
      if (send) sendCmd('music sens ' + v);
    };
    if (mg) { mg.oninput = (e) => syncMusicGain(e.target.value); mg.onchange = (e) => syncMusicGain(e.target.value, true); }
    if (mgNum) { mgNum.oninput = (e) => syncMusicGain(e.target.value); mgNum.onchange = (e) => syncMusicGain(e.target.value, true); }
    const btnProfileQR = document.getElementById('btnProfileQR');
    if (btnProfileQR) {
      btnProfileQR.onclick = () => {
        const blob = (document.getElementById('profileBlob') || {}).value || '';
        const img = document.getElementById('profileQRImg');
        if (!img) return;
        if (!blob.trim()) { img.style.display = 'none'; return; }
        const data = encodeURIComponent(blob.trim());
        img.src = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${data}`;
        img.style.display = 'block';
      };
    }
    const btnExport = document.getElementById('btnExport');
    if (btnExport) btnExport.onclick = () => sendCmd('cfg export');
    document.getElementById('btnImport').onclick = () => {
      const cfg = document.getElementById('importArea').value.trim();
      if (cfg) sendCmd(cfg.startsWith('cfg import') ? cfg : ('cfg import ' + cfg));
    };

    document.getElementById('btnTouchTune').onclick = () => {
      const on = document.getElementById('touchOn').value;
      const off = document.getElementById('touchOff').value;
      sendCmd(`touch tune ${on} ${off}`);
    };
    const btnTouchTuneOff = document.getElementById('btnTouchTuneOff');
    if (btnTouchTuneOff) {
      btnTouchTuneOff.onclick = () => {
        const on = document.getElementById('touchOn').value;
        const off = document.getElementById('touchOff').value;
        sendCmd(`touch tune ${on} ${off}`);
      };
    }
    document.getElementById('btnCalibTouch').onclick = () => sendCmd('calibrate touch');
    document.getElementById('btnCalib').onclick = () => sendCmd('calibrate');

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').then(() => {
          log('Service worker registered');
        }).catch((e) => log('SW register failed: ' + e));
      });
    }
    // Copy GUIDs
    document.body.addEventListener('click', (e) => {
      const target = e.target;
      if (target && target.dataset && target.dataset.copy) {
        const txt = target.dataset.copy;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(txt).then(() => log('Copied: ' + txt)).catch(() => log('Copy failed'));
        } else {
          log('Clipboard not available');
        }
      }
    });
  </script>
</body>
</html>
